# -*- coding: utf-8 -*-
"""The_Stimulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cvKKUx-Q6sY6S8l2yLqw-D6XH7mwB2Ke
"""

#!pip install --force-reinstall qiskit==1.2.0 qiskit-ibm-runtime==0.29.0 qiskit-aer==0.15.0 qiskit-algorithms==0.3.0 matplotlib==3.9.2

from qiskit_ibm_runtime import QiskitRuntimeService

# Clear any existing account to avoid conflicts
QiskitRuntimeService.delete_account()

# Replace with your actual IBM Cloud token and instance name
QiskitRuntimeService.save_account(
    channel="ibm_cloud",
    token="S24GFhGFFjQ54O839cRmwC7bvMY4SNObsh-DaU22uL6g",
    instance="Path_optimization",
    overwrite=True
)

# Load the saved account
service = QiskitRuntimeService()

# List available backends with error handling
print("Available backends:")
for backend in service.backends():
    try:
        qubits = getattr(backend, 'num_qubits', 'N/A')
        print(f"- {backend.name} | Qubits: {qubits}")
    except Exception as e:
        print(f"- {backend.name} | Qubits: N/A (Error: {e})")

"""
Complete Quantum TSP/VRP Solver - IBM Qiskit Backend Runner with Batch Optimization
Standalone version with all necessary classes included
"""

# Quantum TSP/VRP Solver with Real Road Network Integration
# Updated to resolve memory issues, reduce qubit requirements, and improve robustness

import numpy as np
import random
import time
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass
from collections import defaultdict
import logging
import requests
import folium
from sklearn.cluster import KMeans, SpectralClustering
from scipy.sparse.csgraph import minimum_spanning_tree

# Configure logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Quantum Computing Imports
try:
    from qiskit import QuantumCircuit
    from qiskit.providers.basic_provider import BasicProvider
    from qiskit.primitives import Sampler, Estimator
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp
    try:
        from qiskit_ibm_runtime import QiskitRuntimeService, Sampler as IBMSampler, Estimator as IBMEstimator
        IBM_RUNTIME_AVAILABLE = True
    except ImportError:
        IBM_RUNTIME_AVAILABLE = False
    try:
        from qiskit_aer import AerSimulator
        from qiskit_aer.primitives import SamplerV2, EstimatorV2
        AER_AVAILABLE = True
    except ImportError:
        AER_AVAILABLE = False
    try:
        from qiskit_algorithms.optimizers import COBYLA, SPSA, SLSQP
        QISKIT_ALGORITHMS_AVAILABLE = True
    except ImportError:
        QISKIT_ALGORITHMS_AVAILABLE = False
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False
    print("❌ Qiskit not available. Install with: pip install qiskit qiskit-ibm-runtime qiskit-aer qiskit-algorithms")

@dataclass
class Node:
    id: int
    x: float
    y: float
    available_time: str
    demand: float = 0
    time_window: Optional[Tuple[float, float]] = None
    service_time: float = 0

@dataclass
class Vehicle:
    id: int
    capacity: float
    max_time: float = float('inf')
    start_depot: int = 0
    end_depot: int = 0
    type: str = 'car'
    speed: float = 1.0
    fuel_consumption: float = 1.0

class Problem:
    def __init__(self, nodes: List[Node], distance_matrix: np.ndarray = None):
        self.nodes = nodes
        self.n_nodes = len(nodes)
        self.distance_matrix = distance_matrix if distance_matrix is not None else self._calculate_distance_matrix()
        self.metrics = {
            "qubo_size": 0,
            "solution_quality": [],
            "runtime": [],
            "circuit_depth": [],
            "qubits_used": []
        }

    def _calculate_distance_matrix(self) -> np.ndarray:
        n = len(self.nodes)
        distances = np.zeros((n, n))
        cache = {}
        for i in range(n):
            for j in range(n):
                if i != j:
                    key = (self.nodes[i].id, self.nodes[j].id)
                    if key in cache:
                        distances[i][j] = cache[key]
                    else:
                        distance = self._get_osrm_distance(self.nodes[i], self.nodes[j])
                        distances[i][j] = distance if distance is not None else np.inf
                        cache[key] = distances[i][j]
        return distances

    def _get_osrm_distance(self, start_node: Node, end_node: Node) -> Optional[float]:
        return _get_osrm_distance_cached((start_node.x, start_node.y), (end_node.x, end_node.y))

class TSPProblem(Problem):
    def postprocess_quantum_output(self, solution):
        post = PostProcessor()
        return post.repair_tsp_solution_advanced(solution, self)

class VRPProblem(Problem):
    def __init__(self, nodes: List[Node], vehicles: List[Vehicle], distance_matrix: np.ndarray = None, shifts: dict = None):
        super().__init__(nodes, distance_matrix)
        self.vehicles = vehicles
        self.n_vehicles = len(vehicles)
        self.shifts = shifts or {}

    def postprocess_quantum_output(self, solution):
        return list(solution)

class QUBOFormulator:
    def __init__(self, problem_obj: Optional[Problem] = None):
        self.problem_obj = problem_obj

    def vrp_qubo(self, problem: VRPProblem, penalty: float = None):
        n = problem.n_nodes
        K = problem.n_vehicles
        W = problem.distance_matrix
        penalty = np.max(W) * n * K * 5 if penalty is None else penalty
        Q = {}
        DISTANCE_TO_TIME_FACTOR = 0.1

        def add_qubo_term(i, j, coeff):
            Q[(i, j)] = Q.get((i, j), 0) + coeff
        def var_index(i, j, k):
            return k * (n * n) + i * n + j

        for k in range(K):
            vehicle = problem.vehicles[k]
            vehicle_cost_multiplier = vehicle.fuel_consumption / vehicle.speed
            for i in range(n):
                for j in range(n):
                    if i != j:
                        var = var_index(i, j, k)
                        add_qubo_term(var, var, W[i][j] * vehicle_cost_multiplier)

        for j in range(1, n):
            vars_for_node = [var_index(i, j, k) for i in range(n) for k in range(K) if i != j]
            self._add_quadratic_penalty(Q, vars_for_node, penalty)

        for k in range(K):
            for i in range(n):
                vars_incoming = [var_index(j, i, k) for j in range(n) if i != j]
                vars_outgoing = [var_index(i, j, k) for j in range(n) if i != j]
                for u in vars_incoming:
                    for v in vars_outgoing:
                        add_qubo_term(u, v, -2 * penalty)
                for u in vars_incoming:
                    add_qubo_term(u, u, penalty)
                for v in vars_outgoing:
                    add_qubo_term(v, v, penalty)

        for k in range(K):
            vehicle = problem.vehicles[k]
            for i in range(1, n):
                var = var_index(0, i, k)
                demand = problem.nodes[i].demand
                capacity_penalty = penalty * (demand > vehicle.capacity)
                add_qubo_term(var, var, capacity_penalty)

        for k in range(K):
            vehicle = problem.vehicles[k]
            for i in range(n):
                for j in range(n):
                    if i != j:
                        var = var_index(i, j, k)
                        travel_time = W[i][j] * (DISTANCE_TO_TIME_FACTOR / vehicle.speed)
                        service_time = problem.nodes[j].service_time if j != 0 else 0
                        total_time = travel_time + service_time
                        if total_time > vehicle.max_time:
                            add_qubo_term(var, var, penalty * total_time)

        if self.problem_obj:
            self.problem_obj.metrics['qubo_size'] = len(Q)
            logger.info(f"VRP QUBO generated with {len(Q)} terms")
        return Q

    def simplified_tsp_qubo(self, problem: TSPProblem) -> Dict[Tuple[int, int], float]:
        n = problem.n_nodes
        penalty = np.max(problem.distance_matrix) * n * 5 if n > 1 else 1.0
        Q = {}
        var_map = {}
        k = 0
        for i in range(n):
            for j in range(n):
                if i != j:
                    var_map[(i, j)] = k
                    k += 1
        for i in range(n):
            for j in range(n):
                if i != j:
                    var_ij = var_map[(i, j)]
                    Q[(var_ij, var_ij)] = Q.get((var_ij, var_ij), 0) + problem.distance_matrix[i][j]
        for i in range(n):
            outgoing_vars = [var_map[(i, j)] for j in range(n) if i != j]
            incoming_vars = [var_map[(j, i)] for j in range(n) if i != j]
            self._add_quadratic_penalty(Q, outgoing_vars, penalty)
            self._add_quadratic_penalty(Q, incoming_vars, penalty)
        for i in range(1, n):
            for j in range(1, n):
                if i != j:
                    for k in range(1, n):
                        if k != i and k != j:
                            u = var_map.get((i, j))
                            v = var_map.get((j, k))
                            w = var_map.get((k, i))
                            if u is not None and v is not None and w is not None:
                                Q[(u, v)] = Q.get((u, v), 0) + penalty
                                Q[(v, w)] = Q.get((v, w), 0) + penalty
        if self.problem_obj:
            self.problem_obj.metrics['qubo_size'] = len(Q)
            logger.info(f"Simplified TSP QUBO generated with {len(Q)} terms")
        return Q

    def _add_quadratic_penalty(self, Q: Dict, variables: List[int], penalty: float):
        for i in range(len(variables)):
            var_i = variables[i]
            Q[(var_i, var_i)] = Q.get((var_i, var_i), 0) - penalty
            for j in range(i + 1, len(variables)):
                var_j = variables[j]
                v1, v2 = (var_i, var_j) if var_i < var_j else (var_j, var_i)
                Q[(v1, v2)] = Q.get((v1, v2), 0) + 2 * penalty

class QiskitQAOASolver:
    def __init__(self, backend_name='basic_simulator', shots=256, p_layers=1,
                 optimizer='COBYLA', use_real_device=False, use_aer=True, problem_obj: Problem = None):
        if not QISKIT_AVAILABLE:
            raise ImportError("Qiskit not installed")
        self.shots = shots
        self.p_layers = p_layers
        self.use_real_device = use_real_device
        self.problem_obj = problem_obj
        self._setup_local_backend(use_aer)
        if QISKIT_ALGORITHMS_AVAILABLE:
            if optimizer == 'SPSA':
                self.optimizer = SPSA(maxiter=25)
            elif optimizer == 'COBYLA':
                self.optimizer = COBYLA(maxiter=25)
            else:
                self.optimizer = SLSQP(maxiter=25)
        else:
            self.optimizer = None

    def _setup_local_backend(self, use_aer):
        if use_aer and AER_AVAILABLE:
            self.backend = AerSimulator(method='statevector')
            self.sampler = SamplerV2()
            self.estimator = EstimatorV2()
            logger.info("Using Aer simulator with statevector method")
        else:
            provider = BasicProvider()
            self.backend = provider.get_backend('basic_simulator')
            self.sampler = Sampler()
            self.estimator = Estimator()
            logger.info("Using basic Qiskit simulator")

    def qubo_to_ising_hamiltonian(self, Q: Dict[Tuple[int, int], float]) -> Tuple[SparsePauliOp, List[int]]:
        variables = set()
        for (i, j) in Q.keys():
            variables.add(i)
            variables.add(j)
        var_list = sorted(list(variables))
        n_vars = len(var_list)
        var_to_idx = {var: idx for idx, var in enumerate(var_list)}
        pauli_terms = []
        coeffs = []
        constant_term = 0

        for (i, j), weight in Q.items():
            i_idx = var_to_idx[i]
            j_idx = var_to_idx[j]
            if i == j:
                z_pauli = ['I'] * n_vars
                z_pauli[i_idx] = 'Z'
                pauli_terms.append(''.join(z_pauli))
                coeffs.append(-weight / 2.0)
                constant_term += weight / 2.0
            else:
                zz_pauli = ['I'] * n_vars
                zz_pauli[i_idx] = 'Z'
                zz_pauli[j_idx] = 'Z'
                pauli_terms.append(''.join(zz_pauli))
                coeffs.append(weight / 4.0)
                z_i_pauli = ['I'] * n_vars
                z_i_pauli[i_idx] = 'Z'
                pauli_terms.append(''.join(z_i_pauli))
                coeffs.append(-weight / 4.0)
                z_j_pauli = ['I'] * n_vars
                z_j_pauli[j_idx] = 'Z'
                pauli_terms.append(''.join(z_j_pauli))
                coeffs.append(-weight / 4.0)
                constant_term += weight / 4.0

        if constant_term != 0:
            pauli_terms.append('I' * max(1, n_vars))
            coeffs.append(float(constant_term))

        if pauli_terms:
            real_coeffs = [float(np.real(c)) for c in coeffs]
            hamiltonian = SparsePauliOp.from_list(list(zip(pauli_terms, real_coeffs)))
        else:
            hamiltonian = SparsePauliOp.from_list([('I' * max(1, n_vars), 0.0)])

        if self.problem_obj:
            self.problem_obj.metrics['qubo_size'] = n_vars
        return hamiltonian, var_list

    def create_qaoa_circuit(self, hamiltonian: SparsePauliOp, beta: List[float], gamma: List[float]) -> QuantumCircuit:
        n_qubits = hamiltonian.num_qubits
        qc = QuantumCircuit(n_qubits, n_qubits)
        qc.h(range(n_qubits))

        for p in range(self.p_layers):
            for term, weight in zip(hamiltonian.paulis, hamiltonian.coeffs):
                real_weight = float(np.real(weight))
                pauli_str = str(term)
                if pauli_str.count('Z') == 1:
                    indices = [i for i, c in enumerate(reversed(pauli_str)) if c == 'Z']
                    if len(indices) == 1:
                        qc.rz(2 * gamma[p] * real_weight, indices[0])
                elif pauli_str.count('Z') == 2:
                    indices = [i for i, c in enumerate(reversed(pauli_str)) if c == 'Z']
                    if len(indices) == 2:
                        qc.rzz(2 * gamma[p] * real_weight, indices[0], indices[1])
            for i in range(n_qubits):
                qc.rx(2 * beta[p], i)
        qc.measure_all()

        if self.problem_obj:
            self.problem_obj.metrics['circuit_depth'].append(qc.depth())
            self.problem_obj.metrics['qubits_used'].append(n_qubits)
        return qc

    def qaoa_solve(self, Q: Dict[Tuple[int, int], float], num_runs: int = 10) -> Dict:
        try:
            hamiltonian, var_list = self.qubo_to_ising_hamiltonian(Q)
            n_qubits = len(var_list)
            if n_qubits > 20:  # Reduced qubit threshold to avoid memory issues
                logger.warning(f"Qubit count {n_qubits} exceeds safe threshold, using classical fallback")
                return self._fallback_solution(var_list)
            best_solution = None
            best_energy = float('inf')
            quantum_results = []
            circuits = []
            betas = []
            gammas = []

            for run in range(num_runs):
                logger.info(f"Preparing QAOA circuit for run {run + 1}/{num_runs}")
                beta = [random.uniform(0, np.pi) for _ in range(self.p_layers)]
                gamma = [random.uniform(0, np.pi/2) for _ in range(self.p_layers)]
                qc = self.create_qaoa_circuit(hamiltonian, beta, gamma)
                circuits.append(qc)
                betas.append(beta)
                gammas.append(gamma)
                logger.debug(f"Circuit {run + 1}: qubits={n_qubits}, depth={qc.depth()}")

            jobs = [self.sampler.run([qc], shots=self.shots) for qc in circuits]
            for run, (job, beta, gamma) in enumerate(zip(jobs, betas, gammas)):
                logger.info(f"Processing results for run {run + 1}/{num_runs}")
                start_time = time.time()
                try:
                    result = job.result()
                    pub_result = result[0]
                    if hasattr(pub_result.data, 'meas'):
                        data_bin = pub_result.data.meas
                    elif hasattr(pub_result.data, 'bin'):
                        data_bin = pub_result.data.bin
                    else:
                        raise AttributeError("No 'meas' or 'bin' in PubResult.data")
                    counts = data_bin.get_counts() if hasattr(data_bin, 'get_counts') else {}
                    if not counts:
                        logger.warning(f"No counts obtained for run {run + 1}")
                        continue
                    for bitstring, count in counts.items():
                        if count > 0:
                            if isinstance(bitstring, str):
                                try:
                                    bitstring_str = bitstring
                                except ValueError:
                                    logger.warning(f"Invalid bitstring '{bitstring}' skipped")
                                    continue
                            elif isinstance(bitstring, int):
                                bitstring_str = format(bitstring, f"0{n_qubits}b")
                            else:
                                logger.warning(f"Unexpected bitstring type {type(bitstring)}")
                                continue
                            solution = {var_list[i]: int(bit) for i, bit in enumerate(reversed(bitstring_str))}
                            energy = self._calculate_qubo_energy(Q, solution)
                            logger.info(f"Run {run + 1}: Solution energy={energy}, bitstring={bitstring_str}")
                            quantum_results.append({
                                'solution': solution,
                                'energy': energy,
                                'beta': beta,
                                'gamma': gamma
                            })
                            if energy < best_energy:
                                best_energy = energy
                                best_solution = solution
                    if self.problem_obj:
                        self.problem_obj.metrics['runtime'].append(time.time() - start_time)
                        self.problem_obj.metrics['solution_quality'].append(best_energy)
                except Exception as e:
                    logger.error(f"Run {run + 1} failed: {e}, circuit depth: {qc.depth()}, qubits: {n_qubits}")
                    continue

            if best_solution is None:
                logger.warning("No valid solutions found, using fallback")
                return self._fallback_solution(var_list)
            if self.problem_obj:
                best_solution = self.problem_obj.postprocess_quantum_output(best_solution)
            logger.info(f"Best solution found with energy {best_energy}")
            return {
                'solution': best_solution,
                'energy': best_energy,
                'method': 'QAOA',
                'num_qubits': n_qubits,
                'quantum_results': quantum_results
            }
        except Exception as e:
            logger.error(f"QAOA failed: {e}")
            return self._fallback_solution(var_list)

    def _fallback_solution(self, variables: List[int]) -> Dict:
        solution = {var: random.choice([0, 1]) for var in variables}
        return {
            'solution': solution,
            'energy': 0,
            'method': 'classical_fallback',
            'num_qubits': len(variables)
        }

    def _calculate_qubo_energy(self, Q: Dict[Tuple[int, int], float], solution: Dict[int, int]) -> float:
        energy = 0
        for (i, j), weight in Q.items():
            xi = solution.get(i, 0)
            xj = solution.get(j, 0)
            energy += weight * xi * xj
        return energy

class ClassicalPreprocessor:
    def cluster_customers_advanced(self, problem: VRPProblem, method='spectral', max_cluster_size=3) -> Dict[int, List[int]]:
        customers = list(range(1, problem.n_nodes))
        if not customers:
            logger.warning("No customers to cluster")
            return {v.id: [] for v in problem.vehicles}

        coords = np.array([(problem.nodes[i].x, problem.nodes[i].y) for i in customers])
        demands = [problem.nodes[i].demand for i in customers]

        # Adjust number of clusters to balance subproblem sizes
        n_clusters = min(len(problem.vehicles), len(customers))
        if len(customers) > sum(max_cluster_size for _ in problem.vehicles):
            n_clusters = min(len(problem.vehicles), ceil(len(customers) / max_cluster_size))
            logger.info(f"Adjusted n_clusters to {n_clusters} to avoid large subproblems")

        if method == 'spectral':
            clustering = SpectralClustering(n_clusters=n_clusters, affinity='rbf', gamma=0.3, random_state=123)
        else:
            clustering = KMeans(n_clusters=n_clusters, random_state=123)

        labels = clustering.fit_predict(coords)

        clusters = {v.id: [] for v in problem.vehicles}
        for idx, label in enumerate(labels):
            vehicle_idx = label % len(problem.vehicles)
            if len(clusters[problem.vehicles[vehicle_idx].id]) < max_cluster_size:
                clusters[problem.vehicles[vehicle_idx].id].append(customers[idx])

        vehicles_sorted = sorted(problem.vehicles, key=lambda v: v.capacity, reverse=True)
        vehicles_ids_sorted = [v.id for v in vehicles_sorted]

        overflow = []
        for v_id in vehicles_ids_sorted:
            cluster = clusters[v_id]
            vehicle = next(v for v in problem.vehicles if v.id == v_id)
            total_demand = sum(demands[c-1] for c in cluster)
            while total_demand > vehicle.capacity and cluster:
                moved = cluster.pop()
                overflow.append(moved)
                total_demand -= demands[moved-1]

        # Reassign overflow nodes with capacity and size checks
        for moved in overflow[:]:
            assigned = False
            for v_id in vehicles_ids_sorted:
                cluster = clusters[v_id]
                vehicle = next(v for v in problem.vehicles if v.id == v_id)
                total_demand = sum(demands[c-1] for c in cluster)
                if total_demand + demands[moved-1] <= vehicle.capacity and len(cluster) < max_cluster_size:
                    cluster.append(moved)
                    assigned = True
                    overflow.remove(moved)
                    break
            if not assigned:
                logger.warning(f"Node {moved} could not be assigned, deferring")

        # Defer remaining overflow to next shift or next day
        deferred_nodes = []
        for moved in overflow:
            shift_name = problem.nodes[moved].available_time
            shift_num = int(shift_name.split(' ')[1]) if shift_name else 0
            if shift_num < 3:
                next_shift = f"Shift {shift_num + 1}"
                logger.info(f"Node {moved} deferred to {next_shift}")
                problem.shifts.setdefault(next_shift, []).append(problem.nodes[moved])
                deferred_nodes.append((moved, next_shift))
            else:
                logger.warning(f"Node {moved} deferred to next day")
                deferred_nodes.append((moved, "Next Day"))

        # Assign remaining overflow to empty vehicles
        for v_id in vehicles_ids_sorted:
            cluster = clusters[v_id]
            if not cluster and overflow:
                if len(cluster) < max_cluster_size:
                    moved = overflow.pop(0)
                    cluster.append(moved)

        cluster_sizes = {v_id: len(cluster) for v_id, cluster in clusters.items()}
        cluster_qubits = {v_id: (size + 1) * size if size > 0 else 0 for v_id, size in cluster_sizes.items()}
        cluster_demands = {v_id: sum(demands[c-1] for c in clusters[v_id]) for v_id in clusters}
        logger.info(f"Cluster sizes: {cluster_sizes}")
        logger.info(f"Estimated qubits per cluster: {cluster_qubits}")
        logger.info(f"Cluster demands: {cluster_demands}")
        logger.info(f"Deferred nodes: {deferred_nodes}")
        return clusters

class PostProcessor:
    def repair_tsp_solution_advanced(self, solution: Dict[int, int], problem: TSPProblem) -> List[int]:
        n = problem.n_nodes
        var_map = {}
        k = 0
        for i in range(n):
            for j in range(n):
                if i != j:
                    var_map[(i, j)] = k
                    k += 1
        inv_var_map = {v: k for k, v in var_map.items()}
        tour_edges = []
        used_nodes = set()
        for var_index, value in solution.items():
            if value == 1 and var_index in inv_var_map:
                u, v = inv_var_map[var_index]
                if v not in used_nodes or v == 0:
                    tour_edges.append((u, v))
                    used_nodes.add(v)

        tour = []
        if tour_edges:
            start_node = 0
            tour.append(start_node)
            current_node = start_node
            remaining_edges = list(tour_edges)
            while remaining_edges:
                next_edge = None
                for i, (u, v) in enumerate(remaining_edges):
                    if u == current_node and v not in tour[1:]:
                        next_edge = (u, v)
                        break
                if next_edge:
                    tour.append(next_edge[1])
                    current_node = next_edge[1]
                    remaining_edges.remove(next_edge)
                else:
                    break

        if len(set(tour)) == n and tour[0] == 0 and tour[-1] == 0:
            logger.info("Valid tour constructed from QAOA output")
            return self._two_opt_improvement(tour, problem.distance_matrix)

        logger.info("Trying MST-based tour construction")
        adj_matrix = np.full((n, n), np.inf)
        for (u, v) in tour_edges:
            adj_matrix[u, v] = problem.distance_matrix[u, v]
        mst = minimum_spanning_tree(adj_matrix).toarray()
        tour = [0]
        visited = {0}
        for _ in range(n - 1):
            for j in range(n):
                if mst[tour[-1], j] != np.inf and j not in visited:
                    tour.append(j)
                    visited.add(j)
                    break
        tour.append(0)

        if len(set(tour)) == n:
            logger.info("Valid tour constructed via MST")
            return self._two_opt_improvement(tour, problem.distance_matrix)

        logger.warning("Invalid tour, using nearest neighbor fallback")
        tour = [0]
        unvisited = set(range(1, n))
        current = 0
        while unvisited:
            nearest = min(unvisited, key=lambda x: problem.distance_matrix[current][x])
            tour.append(nearest)
            unvisited.remove(nearest)
            current = nearest
        tour.append(0)
        return self._two_opt_improvement(tour, problem.distance_matrix)

    def _two_opt_improvement(self, tour: List[int], distance_matrix: np.ndarray) -> List[int]:
        def tour_distance(t):
            if len(t) <= 1: return 0
            return sum(distance_matrix[t[i]][t[(i+1) % len(t)]] for i in range(len(t)))
        best_tour = tour[:]
        best_distance = tour_distance(best_tour)
        improved = True
        k = 0
        while improved and k < 1000:
            improved = False
            for i in range(len(tour) - 1):
                for j in range(i + 1, len(tour)):
                    if j - i >= 1:
                        new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
                        new_distance = tour_distance(new_tour)
                        if new_distance < best_distance:
                            best_tour = new_tour[:]
                            best_distance = new_distance
                            tour = new_tour[:]
                            improved = True
                            break
                if improved:
                    break
            k += 1
        return best_tour

class QuantumHybridSolver:
    def __init__(self, quantum_backend='qiskit', **kwargs):
        self.formulator = QUBOFormulator(kwargs.get('problem_obj'))
        self.preprocessor = ClassicalPreprocessor()
        self.postprocessor = PostProcessor()
        self.quantum_backend = quantum_backend
        if quantum_backend == 'qiskit' and QISKIT_AVAILABLE:
            self.quantum_solver = QiskitQAOASolver(**kwargs)
        else:
            logger.warning(f"Quantum backend {quantum_backend} not available, using Qiskit simulator")
            if QISKIT_AVAILABLE:
                self.quantum_solver = QiskitQAOASolver(use_real_device=False, use_aer=True, **kwargs)
                self.quantum_backend = 'qiskit_simulator'
            else:
                raise ValueError("Qiskit not available")

    def solve_tsp_quantum(self, problem: TSPProblem, num_runs: int = 5, use_simplified_qubo: bool = True) -> Tuple[List[int], float, Dict]:
        logger.info(f"Solving TSP with {problem.n_nodes} nodes using {self.quantum_backend}")
        qubo = self.formulator.simplified_tsp_qubo(problem)
        logger.info(f"QUBO size: {len(qubo)} terms")
        best_solution = None
        best_energy = float('inf')
        quantum_results = []
        num_qubits = 0
        for run in range(num_runs):
            logger.info(f"Quantum run {run + 1}/{num_runs}")
            try:
                result = self.quantum_solver.qaoa_solve(qubo)
                quantum_results.append(result)
                num_qubits = result['num_qubits']
                if result['energy'] < best_energy:
                    best_energy = result['energy']
                    best_solution = result['solution']
            except Exception as e:
                logger.error(f"Quantum run {run + 1} failed: {e}")
                continue
        if best_solution is None:
            logger.warning("All quantum runs failed, using classical fallback")
            tour, tour_cost, results = self._classical_tsp_fallback(problem)
            results['num_qubits'] = 0
            return tour, tour_cost, results
        tour = self.postprocessor.repair_tsp_solution_advanced(best_solution, problem)
        tour_cost = self._calculate_tour_cost(tour, problem.distance_matrix)
        results = {
            'quantum_results': quantum_results,
            'best_quantum_energy': best_energy,
            'post_processed_cost': tour_cost,
            'method': self.quantum_backend,
            'num_successful_runs': len(quantum_results),
            'num_qubits': num_qubits
        }
        return tour, tour_cost, results

    def solve_vrp_quantum(self, problem: VRPProblem, num_runs: int = 3, clustering_method: str = 'spectral') -> Tuple[Dict[int, List[int]], float, Dict]:
        logger.info(f"Solving VRP with {problem.n_nodes} nodes, {problem.n_vehicles} vehicles")
        clusters_by_vehicle = self.preprocessor.cluster_customers_advanced(problem, clustering_method, max_cluster_size=4)
        total_cost = 0
        all_routes_by_vehicle = {}
        all_results = []
        total_qubits_estimated = 0
        deferred_nodes = []  # Track nodes deferred to next day
        shift_order = ["Shift 1", "Shift 2", "Shift 3"]
        current_shift_index = shift_order.index([shift for shift, nodes in problem.shifts.items() if problem.nodes[1] in nodes][0]) if problem.nodes[1:] else -1

        for vehicle_id, cluster in clusters_by_vehicle.items():
            if not cluster:
                continue
            logger.info(f"Solving cluster for Vehicle {vehicle_id}: nodes {cluster}")
            cluster_node_indices = [0] + cluster
            cluster_nodes = [problem.nodes[idx] for idx in cluster_node_indices]
            cluster_distances = self._extract_subproblem_distances(problem, cluster_node_indices)
            sub_problem = TSPProblem(cluster_nodes, cluster_distances)
            tour, cost, sub_results = self.solve_tsp_quantum(sub_problem, max(1, num_runs // len(clusters_by_vehicle)), use_simplified_qubo=True)
            original_tour = [cluster_node_indices[node_idx] for node_idx in tour]
            all_routes_by_vehicle[vehicle_id] = original_tour
            total_cost += cost
            all_results.append(sub_results)
            total_qubits_estimated += sub_results.get('num_qubits', 0)

        # Check and reassign exceeding customers
        modified_routes, reassigned_customers = reassign_exceeding_customers(problem, all_routes_by_vehicle, shift_order[current_shift_index])
        all_routes_by_vehicle = modified_routes

        # Handle reassigned customers
        for customer_id in reassigned_customers:
            if current_shift_index < len(shift_order) - 1:
                # Move to next shift
                next_shift = shift_order[current_shift_index + 1]
                logger.info(f"Moving node {customer_id} to {next_shift}")
                problem.shifts[next_shift].append(problem.nodes[customer_id])
            else:
                # Last shift: defer to next day
                logger.info(f"Node {customer_id} deferred to next day in {shift_order[current_shift_index]}")
                deferred_nodes.append((customer_id, shift_order[current_shift_index]))

        # Recalculate total cost for modified routes
        total_cost = sum(self._calculate_tour_cost(all_routes_by_vehicle[vehicle_id], problem.distance_matrix)
                         for vehicle_id in all_routes_by_vehicle if all_routes_by_vehicle[vehicle_id])

        vrp_results = {
            'clustering_method': clustering_method,
            'clusters': clusters_by_vehicle,
            'subproblem_results': all_results,
            'total_cost': total_cost,
            'num_routes': len(all_routes_by_vehicle),
            'total_estimated_qubits': total_qubits_estimated,
            'deferred_nodes': deferred_nodes
        }
        return all_routes_by_vehicle, total_cost, vrp_results

    def _extract_subproblem_distances(self, problem: Problem, node_indices: List[int]) -> np.ndarray:
        n = len(node_indices)
        sub_distances = np.zeros((n, n))
        for i in range(n):
            for j in range(n):
                orig_i = node_indices[i]
                orig_j = node_indices[j]
                sub_distances[i][j] = problem.distance_matrix[orig_i][orig_j]
        return sub_distances

    def _calculate_tour_cost(self, tour: List[int], distance_matrix: np.ndarray) -> float:
        if len(tour) <= 1:
            return 0
        cost = 0
        for i in range(len(tour)):
            j = (i + 1) % len(tour)
            if tour[i] < distance_matrix.shape[0] and tour[j] < distance_matrix.shape[1]:
                cost += distance_matrix[tour[i]][tour[j]]
            else:
                logger.warning(f"Invalid index in tour: {tour[i]} or {tour[j]}")
        return cost

    def _classical_tsp_fallback(self, problem: TSPProblem) -> Tuple[List[int], float, Dict]:
        logger.info("Using classical 2-opt fallback")
        tour, cost = ClassicalSolver().solve_tsp_2opt(problem)
        return tour, cost, {'method': 'classical_2opt'}

def create_random_vrp(n_nodes: int, n_vehicles: int, seed: int = None) -> VRPProblem:
    if seed is not None:
        random.seed(seed)
        np.random.seed(seed)
    depot_lon, depot_lat = -73.9857, 40.7484
    nodes = [Node(0, depot_lon, depot_lat, available_time=None, demand=0)]
    for i in range(1, n_nodes):
        lon = depot_lon + random.uniform(-0.1, 0.1)
        lat = depot_lat + random.uniform(-0.1, 0.1)
        nodes.append(Node(i, lon, lat, available_time=None, demand=10))
    vehicles = [
        Vehicle(0, capacity=60, type='truck', speed=0.7, fuel_consumption=2.5, max_time=8.0),
        Vehicle(1, capacity=30, type='car', speed=1.0, fuel_consumption=1.0, max_time=8.0),
        Vehicle(2, capacity=30, type='car', speed=1.0, fuel_consumption=1.0, max_time=8.0),
        Vehicle(3, capacity=10, type='bike', speed=0.5, fuel_consumption=0.2, max_time=4.0),
        Vehicle(4, capacity=10, type='bike', speed=0.5, fuel_consumption=0.2, max_time=4.0)
    ]
    if n_vehicles > len(vehicles):
        vehicles.extend([Vehicle(i, capacity=24, max_time=8.0) for i in range(len(vehicles), n_vehicles)])
    elif n_vehicles < len(vehicles):
        vehicles = vehicles[:n_vehicles]
    return VRPProblem(nodes, vehicles)

def create_test_problems():
    tsp_nodes = [
        Node(0, -73.9857, 40.7484, available_time=None),
        Node(1, -73.9680, 40.7850, available_time=None),
        Node(2, -73.9934, 40.7589, available_time=None),
        Node(3, -74.0134, 40.7041, available_time=None),
        Node(4, -73.9597, 40.7661, available_time=None)
    ]
    tsp_problem = TSPProblem(tsp_nodes)
    vrp_nodes = [
        # Shift 1 (Nodes 0–12)
        Node(0, -73.9857, 40.7484, demand=0, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(1, -73.9680, 40.7850, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(2, -73.9934, 40.7589, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(3, -74.0134, 40.7041, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(4, -73.9597, 40.7661, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(5, -73.9978, 40.7209, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(6, -73.9813, 40.7736, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(7, -74.0059, 40.7403, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(8, -73.9772, 40.7587, demand=10, service_time=3, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(9, -74.0091, 40.7128, demand=10, service_time=4, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(10, -73.9867, 40.7305, demand=10, service_time=6, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(11, -73.9442, 40.7789, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),
        Node(12, -73.9911, 40.7505, demand=10, service_time=0.5, available_time="Shift 1", time_window=(8.0, 12.0)),

        # Shift 2 (Nodes 0–12)
        Node(0, -73.9857, 40.7484, demand=0, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(1, -73.9700, 40.7800, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(2, -73.9950, 40.7600, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(3, -74.0100, 40.7060, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(4, -73.9570, 40.7680, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(5, -73.9990, 40.7220, demand=10, service_time=3, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(6, -73.9830, 40.7750, demand=10, service_time=4, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(7, -74.0070, 40.7420, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(8, -73.9750, 40.7560, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(9, -74.0110, 40.7100, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(10, -73.9880, 40.7320, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(11, -73.9460, 40.7760, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),
        Node(12, -73.9930, 40.7520, demand=10, service_time=0.5, available_time="Shift 2", time_window=(12.0, 16.0)),

        # Shift 3 (Nodes 0–12)
        Node(0, -73.9857, 40.7484, demand=0, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(1, -73.9660, 40.7870, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(2, -73.9910, 40.7570, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(3, -74.0150, 40.7020, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(4, -73.9610, 40.7640, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(5, -73.9950, 40.7190, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(6, -73.9790, 40.7710, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(7, -74.0030, 40.7380, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(8, -73.9730, 40.7600, demand=10, service_time=4, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(9, -74.0070, 40.7140, demand=10, service_time=5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(10, -73.9840, 40.7280, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(11, -73.9480, 40.7800, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
        Node(12, -73.9890, 40.7480, demand=10, service_time=0.5, available_time="Shift 3", time_window=(16.0, 20.0)),
    ]

    vehicles = [
        Vehicle(0, capacity=60, type='truck', speed=0.7, fuel_consumption=2.5, max_time=8.0),
        Vehicle(1, capacity=30, type='car', speed=1.0, fuel_consumption=1.0, max_time=8.0),
        Vehicle(2, capacity=30, type='car', speed=1.0, fuel_consumption=1.0, max_time=8.0),
        Vehicle(3, capacity=10, type='bike', speed=0.5, fuel_consumption=0.2, max_time=4.0),
        Vehicle(4, capacity=10, type='bike', speed=0.5, fuel_consumption=0.2, max_time=4.0)
    ]

    vrp_problem = VRPProblem(vrp_nodes, vehicles, shifts=group_nodes_by_shift(vrp_nodes))

    return tsp_problem, vrp_problem

def get_route_geometry_from_osrm(start_node: Node, end_node: Node) -> List[tuple]:
    start_lon, start_lat = start_node.x, start_node.y
    end_lon, end_lat = end_node.x, end_node.y
    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {"overview": "full", "geometries": "geojson"}
    try:
        response = requests.get(url, params=params, timeout=5)
        response.raise_for_status()
        data = response.json()
        if data['code'] != 'Ok':
            logger.warning(f"OSRM could not find a route from node {start_node.id} to {end_node.id}")
            return None
        route_geometry = data['routes'][0]['geometry']['coordinates']
        return [(lat, lon) for lon, lat in route_geometry]
    except requests.exceptions.RequestException as e:
        logger.error(f"Error calling OSRM API: {e}")
        return None

def visualize_solution_with_folium(problem, routes_by_vehicle, title, vehicle_info_map, traffic_recommendations=None):
    """
    Visualize VRP solution with folium, handling shift-specific filenames and traffic-aware routes.
    """
    depot_node = problem.nodes[0]
    map_center = [depot_node.y, depot_node.x]

    # Create map with high-visibility tiles
    m = folium.Map(
        location=map_center,
        zoom_start=12,
        tiles="CartoDB Positron"
    )

    # Add depot marker
    folium.Marker(
        location=[depot_node.y, depot_node.x],
        popup="<strong>Depot (Node 0)</strong>",
        tooltip="Depot",
        icon=folium.Icon(color='black', icon='home', prefix='fa')
    ).add_to(m)

    # Add customer markers
    for node in problem.nodes[1:]:
        folium.Marker(
            location=[node.y, node.x],
            popup=f"<strong>Customer {node.id}</strong><br>Demand: {node.demand}",
            tooltip=f"Customer {node.id}",
            icon=folium.Icon(color='gray', icon='user', prefix='fa')
        ).add_to(m)

    # Draw routes
    for vehicle_id, route in routes_by_vehicle.items():
        if not route:
            continue

        vehicle_details = vehicle_info_map.get(vehicle_id, {
            'color': 'blue',
            'label': f'Vehicle {vehicle_id}'
        })
        route_color = vehicle_details['color']
        route_label = vehicle_details['label']

        # Ensure route starts and ends at depot
        viz_route = route[:]
        if viz_route[0] != 0:
            viz_route.insert(0, 0)
        if viz_route[-1] != 0:
            viz_route.append(0)

        # Check for traffic recommendations
        has_alternatives = False
        if traffic_recommendations and vehicle_id in traffic_recommendations:
            rec = traffic_recommendations[vehicle_id]
            has_alternatives = (rec.get('status') == 'alternative' and
                              'alternatives_found' in rec and rec['alternatives_found'])

        # Draw route segments
        for j in range(len(viz_route) - 1):
            start_node_id = viz_route[j]
            end_node_id = viz_route[j + 1]

            # Skip if same node
            if start_node_id == end_node_id:
                continue

            # Determine if this segment should use alternative path
            use_alternative_path = False
            segment_label_suffix = ""

            if has_alternatives:
                rec = traffic_recommendations[vehicle_id]
                for alt in rec.get('alternatives_found', []):
                    seg = alt.get('segment', {})
                    if (seg.get('start_node') == start_node_id and
                        seg.get('end_node') == end_node_id):
                        use_alternative_path = True
                        segment_label_suffix = " (Optimized Route)"
                        break

            start_node = problem.nodes[start_node_id]
            end_node = problem.nodes[end_node_id]

            # Get route geometry
            path_geometry = get_route_geometry_from_osrm_fixed(
                start_node, end_node, use_alternative=use_alternative_path
            )

            if path_geometry:
                # Choose line style based on route type
                line_weight = 5 if use_alternative_path else 3
                line_opacity = 0.9 if use_alternative_path else 0.7

                folium.PolyLine(
                    locations=path_geometry,
                    color=route_color,
                    weight=line_weight,
                    opacity=line_opacity,
                    tooltip=f"{route_label}: {start_node_id}→{end_node_id}{segment_label_suffix}",
                    popup=f"Distance: {problem.distance_matrix[start_node_id][end_node_id]:.2f}km"
                ).add_to(m)
            else:
                # Fallback: draw straight line if OSRM fails
                logger.warning(f"Drawing straight line for {start_node_id}->{end_node_id}")
                folium.PolyLine(
                    locations=[[start_node.y, start_node.x], [end_node.y, end_node.x]],
                    color=route_color,
                    weight=2,
                    opacity=0.5,
                    dash_array="5,5",  # Dashed line to indicate approximation
                    tooltip=f"{route_label}: {start_node_id}→{end_node_id} (Direct)"
                ).add_to(m)

    # Add legend
    legend_html = f"""
    <div style="position: fixed;
                top: 10px; right: 10px; width: 200px; height: auto;
                background-color: white; border:2px solid grey; z-index:9999;
                font-size:14px; padding: 10px">
    <p><b>{title}</b></p>
    """

    for vehicle_id, details in vehicle_info_map.items():
        if vehicle_id in routes_by_vehicle and routes_by_vehicle[vehicle_id]:
            legend_html += f'<p><i class="fa fa-minus" style="color:{details["color"]}"></i> {details["label"]}</p>'

    legend_html += "</div>"
    m.get_root().html.add_child(folium.Element(legend_html))

    # Generate shift-specific filename
    # shift_name = title.split(' - ')[-1]  # Get the last part (e.g., 'Shift 1')
    # filename = f"vrp_{shift_name.lower().replace(' ', '_')}.html"  # e.g., vrp_shift_1.html
    filename = f"{title.replace(' ', '_').lower()}.html"

    # Save map
    try:
        m.save(filename)
        print(f"✅ Visualization saved to '{filename}'")
        return filename
    except Exception as e:
        logger.error(f"Failed to save map '{filename}': {e}")
        return None

def print_solution_schedules(problem: VRPProblem, routes: Dict[int, List[int]], shift_name: str, deferred_nodes: List[Tuple[int, str]]):
    print("\n" + "-"*80)
    print(f"VRP DETAILED SCHEDULE & SHIFT ANALYSIS - {shift_name}")
    print("-"*80)
    if not routes:
        print("No routes to analyze.")
    else:
        DISTANCE_TO_TIME_FACTOR = 0.1
        sorted_vehicle_ids = sorted(routes.keys())
        for vehicle_id in sorted_vehicle_ids:
            route = routes[vehicle_id]
            if not route:
                continue
            vehicle = next((v for v in problem.vehicles if v.id == vehicle_id), None)
            if not vehicle:
                continue
            print(f"\n Vehicle {vehicle.id} ({vehicle.type}) | Shift: [{vehicle.max_time:.2f} hours]")
            print("-" * 75)
            print(f"{'Node':>5} | {'Arrival Time':>12} | {'Service End':>12} | {'Remaining Shift Time':>25}")
            print(f"{'-----':>5} | {'------------':>12} | {'-----------':>12} | {'-------------------------':>25}")
            current_time = 0.0
            previous_node = 0
            print(f"{0:>5} | {current_time:>12.2f} | {current_time:>12.2f} | {(vehicle.max_time - current_time):>25.2f}")
            full_route = route[:]
            if full_route[0] != 0: full_route.insert(0, 0)
            if full_route[-1] != 0: full_route.append(0)
            total_travel_time = 0
            total_service_time = 0
            for node_id in full_route[1:]:
                travel_distance = problem.distance_matrix[previous_node][node_id]
                travel_time = travel_distance * (DISTANCE_TO_TIME_FACTOR / vehicle.speed)
                total_travel_time += travel_time
                arrival_time = current_time + travel_time
                node = problem.nodes[node_id]
                service_time = node.service_time
                if node_id != 0:
                    total_service_time += service_time
                    departure_time = arrival_time + service_time
                else:
                    departure_time = arrival_time
                remaining_shift_time = vehicle.max_time - departure_time
                print(f"{node_id:>5} | {arrival_time:>12.2f} | {departure_time:>12.2f} | {remaining_shift_time:>25.2f}")
                current_time = departure_time
                previous_node = node_id
                if remaining_shift_time < 0:
                    print(f"     **** WARNING: Vehicle {vehicle.id} shift exceeded by {-remaining_shift_time:.2f} hours! ****")
            total_route_duration = current_time
            print("-" * 75)
            print(f"Route Summary for Vehicle {vehicle.id}: Total Duration = {total_route_duration:.2f} hours")
            print(f"                             (Travel Time: {total_travel_time:.2f}, Service Time: {total_service_time:.2f})")

    # Print deferred nodes
    if deferred_nodes:
        print("\nDeferred Deliveries:")
        for node_id, shift in deferred_nodes:
            print(f"  Node {node_id}: Scheduled for next day in {shift}")
    print("\n" + "-"*80 + "\n")

def calculate_route_details(problem: VRPProblem, vehicle: Vehicle, route: List[int]) -> Dict:
    DISTANCE_TO_TIME_FACTOR = 0.1
    total_distance = 0
    total_travel_time = 0
    total_service_time = 0
    total_fuel_cost = 0
    if len(route) > 1:
        full_route = route[:]
        if full_route[0] != 0: full_route.insert(0, 0)
        if full_route[-1] != 0: full_route.append(0)
        for i in range(len(full_route) - 1):
            start_node_id = full_route[i]
            end_node_id = full_route[i+1]
            distance = problem.distance_matrix[start_node_id][end_node_id]
            total_distance += distance
            total_travel_time += distance * (DISTANCE_TO_TIME_FACTOR / vehicle.speed)
    total_service_time = sum(problem.nodes[node_id].service_time for node_id in route if node_id != 0)
    total_route_duration = total_travel_time + total_service_time
    total_fuel_cost = total_distance * vehicle.fuel_consumption
    return {
        'total_distance': total_distance,
        'total_travel_time': total_travel_time,
        'total_service_time': total_service_time,
        'total_duration': total_route_duration,
        'total_fuel_cost': total_fuel_cost,
        'route': route
    }

def print_detailed_vehicle_summary(problem: VRPProblem, routes_by_vehicle: Dict[int, List[int]]):
    print("\n" + "=" * 100)
    print("DETAILED VRP SOLUTION SUMMARY: VEHICLE PERFORMANCE & COST ANALYSIS")
    print("=" * 100)
    header = f"{'Vehicle ID':<12} | {'Type':<10} | {'Max Time (hrs)':<14} | {'Total Distance (km)':<20} | {'Total Duration (hrs)':<20} | {'Total Fuel Cost':<18}"
    print(header)
    print("-" * 100)
    total_fleet_cost = 0
    sorted_vehicle_ids = sorted(routes_by_vehicle.keys())
    for vehicle_id in sorted_vehicle_ids:
        route = routes_by_vehicle[vehicle_id]
        if not route:
            continue
        vehicle = next((v for v in problem.vehicles if v.id == vehicle_id), None)
        if not vehicle:
            continue
        details = calculate_route_details(problem, vehicle, route)
        total_fleet_cost += details['total_fuel_cost']
        line = (f"{vehicle_id:<12} | {vehicle.type:<10} | {vehicle.max_time:<14.2f} | "
                f"{details['total_distance']:<20.2f} | {details['total_duration']:<20.2f} | "
                f"{details['total_fuel_cost']:<18.2f}")
        print(line)
        if details['total_duration'] > vehicle.max_time:
            print(f"   ⚠️  WARNING: Vehicle {vehicle_id} exceeded its max time by {details['total_duration'] - vehicle.max_time:.2f} hours!")
    print("-" * 100)
    print(f"{'TOTAL FLEET COST':<60} | {total_fleet_cost:>30.2f}")
    print("=" * 100 + "\n")

def check_quantum_connectivity():
    print("🔍 Checking IBM Quantum connectivity...")
    try:
        from qiskit_ibm_runtime import QiskitRuntimeService
        service = QiskitRuntimeService()
        print("✓ Successfully connected to IBM Quantum!")
        print("\nAvailable backends:")
        backends = service.backends()
        quantum_backends = []
        simulator_backends = []
        for backend in backends:
            if backend.simulator:
                simulator_backends.append(backend)
            else:
                quantum_backends.append(backend)
            try:
                status = "🟢" if backend.status().operational else "🔴"
                queue = backend.status().pending_jobs if hasattr(backend.status(), 'pending_jobs') else 0
                qubits = backend.num_qubits if hasattr(backend, 'num_qubits') else 'N/A'
                print(f"  {status} {backend.name} | Qubits: {qubits} | Queue: {queue}")
            except Exception as e:
                logger.warning(f"Could not get status for backend {backend.name}: {e}")
                print(f"  ❓ {backend.name} | Qubits: N/A | Queue: N/A")
        print(f"\n📊 Summary:")
        print(f"  Quantum devices: {len(quantum_backends)}")
        print(f"  Simulators: {len(simulator_backends)}")
        if quantum_backends:
            try:
                operational_backends = [b for b in quantum_backends if b.status().operational and hasattr(b, 'num_qubits') and b.num_qubits > 0]
                if operational_backends:
                    recommended = min(operational_backends, key=lambda b: b.status().pending_jobs if hasattr(b.status(), 'pending_jobs') else float('inf'))
                    print(f"  Recommended: {recommended.name} ({recommended.num_qubits} qubits)")
                else:
                    print("  No operational quantum devices available.")
            except Exception as e:
                logger.warning(f"Could not determine recommended backend: {e}")
                print("  Could not determine recommended quantum device.")
        return True
    except Exception as e:
        print(f"❌ Failed to connect to IBM Quantum: {e}")
        return False

def find_vrp_qubit_requirement(n_nodes: int, n_vehicles: int):
    print(f"\nEstimating qubit count for VRP with {n_nodes} nodes and {n_vehicles} vehicles...")
    try:
        vrp_problem = create_random_vrp(n_nodes, n_vehicles, seed=456)
        preprocessor = ClassicalPreprocessor()
        clusters = preprocessor.cluster_customers_advanced(vrp_problem, max_cluster_size=4)
        max_qubits_needed = 0
        if clusters:
            largest_cluster_size = max(len(cluster) for cluster in clusters.values())
            logger.info(f"Largest cluster size (excluding depot): {largest_cluster_size}")
            nodes_in_largest_subproblem = largest_cluster_size + 1
            if nodes_in_largest_subproblem > 1:
                estimated_qubits = nodes_in_largest_subproblem * (nodes_in_largest_subproblem - 1)
                max_qubits_needed = estimated_qubits
                print(f"Estimated qubits needed: {estimated_qubits}")
            else:
                print("Largest subproblem too small, 0 qubits needed.")
        else:
            print("No clusters formed.")
        return max_qubits_needed
    except Exception as e:
        logger.error(f"Qubit estimation failed: {e}")
        print(f"Error estimating qubits: {e}")
        return 0

def run_ibm_quantum_experiments():
    """Run quantum VRP experiments with traffic-aware rerouting for each shift."""
    print("=" * 80)
    print("RUNNING QUANTUM VRP WITH TRAFFIC-AWARE OPTIMIZATION")
    print("=" * 80)

    tsp_problem, vrp_problem = create_test_problems()
    print(f"TSP Problem: {tsp_problem.n_nodes} nodes")
    print(f"VRP Problem: {vrp_problem.n_nodes} nodes, {vrp_problem.n_vehicles} vehicles, {len(vrp_problem.shifts)} shifts")

    vehicle_color_map = {
        0: {'color': 'red', 'label': 'Truck 1'},
        1: {'color': 'blue', 'label': 'Car 1'},
        2: {'color': 'green', 'label': 'Car 2'},
        3: {'color': 'orange', 'label': 'Bike 1'},
        4: {'color': 'purple', 'label': 'Bike 2'}
    }

    test_configs = [
        {
            'name': 'IBM Aer Simulator (MPS with Traffic)',
            'use_real_device': False,
            'use_aer': True,
            'shots': 1024,
            'p_layers': 3,
            'optimizer': 'COBYLA'
        }
    ]

    results = {}
    api_key = "rF4ssuOAjyta2iqAYmlf1bZz0Itm2c8L"

    for config in test_configs:
        print(f"\n{'-' * 60}")
        print(f"TESTING: {config['name']}")
        print(f"{'-' * 60}")
        config_results = {'tsp': None, 'vrp': {}}

        try:
            solver = QuantumHybridSolver(
                quantum_backend='qiskit',
                use_real_device=config['use_real_device'],
                use_aer=config.get('use_aer', True),
                shots=config['shots'],
                p_layers=config['p_layers'],
                optimizer=config['optimizer'],
                problem_obj=tsp_problem if config['name'] == 'IBM Quantum (Real Device)' else None
            )
        except Exception as init_e:
            logger.error(f"Solver initialization failed for {config['name']}: {init_e}")
            config_results['initialization_error'] = str(init_e)
            results[config['name']] = config_results
            continue

        # Solve TSP
        print(f"\n🚗 Solving TSP ({tsp_problem.n_nodes} nodes)...")
        start_time = time.time()
        try:
            tsp_tour, tsp_cost, tsp_details = solver.solve_tsp_quantum(tsp_problem, num_runs=2)
            tsp_time = time.time() - start_time
            config_results['tsp'] = {
                'tour': tsp_tour,
                'cost': tsp_cost,
                'time': tsp_time,
                'details': tsp_details,
                'success': True,
                'num_qubits': tsp_details.get('num_qubits', 'N/A')
            }
            print(f"✓ TSP Solution: Cost = {tsp_cost:.2f} km, Time = {tsp_time:.2f}s, Qubits = {config_results['tsp']['num_qubits']}")
        except Exception as e:
            print(f"❌ TSP failed: {e}")
            config_results['tsp'] = {'success': False, 'error': str(e)}

        # Solve VRP for each shift with traffic analysis
        for shift_name in ["Shift 1", "Shift 2", "Shift 3"]:
            shift_nodes = vrp_problem.shifts.get(shift_name, [])
            if not shift_nodes:
                print(f"❌ No nodes found for {shift_name}")
                config_results['vrp'][shift_name] = {'success': False, 'error': 'No nodes for shift'}
                continue
            print(f"\n🚚 Solving VRP for {shift_name} ({len(shift_nodes)} nodes, {vrp_problem.n_vehicles} vehicles)...")
            shift_indices = [node.id for node in shift_nodes]
            shift_distance_matrix = vrp_problem.distance_matrix[np.ix_(shift_indices, shift_indices)]
            shift_vrp_problem = VRPProblem(nodes=shift_nodes, vehicles=vrp_problem.vehicles, distance_matrix=shift_distance_matrix, shifts=vrp_problem.shifts)
            start_time = time.time()
            try:
                vrp_routes, vrp_cost, vrp_details = solver.solve_vrp_quantum(
                    shift_vrp_problem,
                    num_runs=2,
                    clustering_method='spectral'
                )
                vrp_time = time.time() - start_time
                config_results['vrp'][shift_name] = {
                    'routes': vrp_routes,
                    'cost': vrp_cost,
                    'time': vrp_time,
                    'details': vrp_details,
                    'success': True,
                    'total_estimated_qubits': vrp_details.get('total_estimated_qubits', 'N/A'),
                    'deferred_nodes': vrp_details.get('deferred_nodes', [])
                }
                print(f"✓ VRP Solution for {shift_name}: Cost = {vrp_cost:.2f} km, Time = {vrp_time:.2f}s, Est. Qubits = {config_results['vrp'][shift_name]['total_estimated_qubits']}")
                print(f"  Routes: {vrp_routes}")
                print(f"  Clusters: {vrp_details.get('clusters', [])}")

                # Apply traffic-aware rerouting
                current_positions = {vid: 0 for vid in vrp_routes.keys()}
                traffic_recommendations = traffic_aware_rerouting_fixed(
                    shift_vrp_problem, vrp_routes, api_key, current_positions
                )

                # Traffic optimization summary
                print(f"\n{'=' * 60}")
                print(f"TRAFFIC OPTIMIZATION SUMMARY FOR {shift_name}")
                print(f"{'=' * 60}")
                total_original_time = 0
                total_optimized_time = 0
                vehicles_with_improvements = 0
                for vehicle_id, rec in traffic_recommendations.items():
                    total_original_time += rec['original_time']
                    total_optimized_time += rec['total_time']
                    if rec['status'] == 'alternative':
                        vehicles_with_improvements += 1
                total_time_saved = total_original_time - total_optimized_time
                efficiency_gain = (total_time_saved / total_original_time * 100) if total_original_time > 0 else 0
                print(f"Vehicles analyzed: {len(traffic_recommendations)}")
                print(f"Vehicles with route improvements: {vehicles_with_improvements}")
                print(f"Total original time: {total_original_time:.2f} hours")
                print(f"Total optimized time: {total_optimized_time:.2f} hours")
                print(f"Total time saved: {total_time_saved:.2f} hours")
                print(f"Overall efficiency gain: {efficiency_gain:.1f}%")

                # Store traffic recommendations
                config_results['vrp'][shift_name]['traffic_recommendations'] = traffic_recommendations

                # Visualize and print schedules
                if vrp_routes:
                    print_solution_schedules(shift_vrp_problem, vrp_routes, shift_name, vrp_details.get('deferred_nodes', []))
                    print_detailed_vehicle_summary(shift_vrp_problem, vrp_routes)
                    visualize_solution_with_folium(shift_vrp_problem, vrp_routes, f"VRP - {config['name']} - {shift_name}", vehicle_color_map)
                    download_vrp_visualizations(
                        problem=shift_vrp_problem,
                        shift_name=shift_name,
                        routes_by_vehicle=vrp_routes,
                        traffic_recommendations=traffic_recommendations
                    )
            except Exception as e:
                print(f"❌ VRP failed for {shift_name}: {e}")
                config_results['vrp'][shift_name] = {'success': False, 'error': str(e)}
        results[config['name']] = config_results

    # Results summary
    print(f"\n{'=' * 80}")
    print("EXPERIMENT RESULTS SUMMARY")
    print(f"{'=' * 80}")
    print(f"\n{'Configuration':<25} | {'TSP Cost':<10} | {'TSP Time':<10} | {'TSP Qubits':<12} | {'VRP Shift 1 Cost':<15} | {'VRP Shift 1 Time':<15} | {'VRP Shift 1 Qubits':<18} | {'VRP Shift 1 Efficiency':<20} | {'VRP Shift 2 Cost':<15} | {'VRP Shift 2 Time':<15} | {'VRP Shift 2 Qubits':<18} | {'VRP Shift 2 Efficiency':<20} | {'VRP Shift 3 Cost':<15} | {'VRP Shift 3 Time':<15} | {'VRP Shift 3 Qubits':<18} | {'VRP Shift 3 Efficiency':<20}")
    print("-" * 220)
    for config_name, config_results in results.items():
        if 'initialization_error' in config_results:
            print(f"{config_name:<25} | {'FAILED':<10} | {'N/A':<10} | {'N/A':<12} | {'FAILED':<15} | {'N/A':<15} | {'N/A':<18} | {'N/A':<20} | {'FAILED':<15} | {'N/A':<15} | {'N/A':<18} | {'N/A':<20} | {'FAILED':<15} | {'N/A':<15} | {'N/A':<18} | {'N/A':<20}")
            continue
        tsp_cost = "FAILED"
        tsp_time = "N/A"
        tsp_qubits = "N/A"
        vrp_costs = {"Shift 1": "FAILED", "Shift 2": "FAILED", "Shift 3": "FAILED"}
        vrp_times = {"Shift 1": "N/A", "Shift 2": "N/A", "Shift 3": "N/A"}
        vrp_qubits = {"Shift 1": "N/A", "Shift 2": "N/A", "Shift 3": "N/A"}
        vrp_efficiency = {"Shift 1": "N/A", "Shift 2": "N/A", "Shift 3": "N/A"}
        if config_results.get('tsp') and config_results['tsp'].get('success'):
            tsp_cost = f"{config_results['tsp']['cost']:.2f}"
            tsp_time = f"{config_results['tsp']['time']:.2f}s"
            tsp_qubits = config_results['tsp']['num_qubits']
        for shift_name in ["Shift 1", "Shift 2", "Shift 3"]:
            if config_results['vrp'].get(shift_name) and config_results['vrp'][shift_name].get('success'):
                vrp_costs[shift_name] = f"{config_results['vrp'][shift_name]['cost']:.2f}"
                vrp_times[shift_name] = f"{config_results['vrp'][shift_name]['time']:.2f}s"
                vrp_qubits[shift_name] = config_results['vrp'][shift_name]['total_estimated_qubits']
                if 'traffic_recommendations' in config_results['vrp'][shift_name]:
                    total_original_time = sum(rec['original_time'] for rec in config_results['vrp'][shift_name]['traffic_recommendations'].values())
                    total_optimized_time = sum(rec['total_time'] for rec in config_results['vrp'][shift_name]['traffic_recommendations'].values())
                    efficiency_gain = (total_original_time - total_optimized_time) / total_original_time * 100 if total_original_time > 0 else 0
                    vrp_efficiency[shift_name] = f"{efficiency_gain:.1f}%"
        print(f"{config_name:<25} | {tsp_cost:<10} | {tsp_time:<10} | {str(tsp_qubits):<12} | {vrp_costs['Shift 1']:<15} | {vrp_times['Shift 1']:<15} | {str(vrp_qubits['Shift 1']):<18} | {vrp_efficiency['Shift 1']:<20} | {vrp_costs['Shift 2']:<15} | {vrp_times['Shift 2']:<15} | {str(vrp_qubits['Shift 2']):<18} | {vrp_efficiency['Shift 2']:<20} | {vrp_costs['Shift 3']:<15} | {vrp_times['Shift 3']:<15} | {str(vrp_qubits['Shift 3']):<18} | {vrp_efficiency['Shift 3']:<20}")

    # Deferred nodes summary
    print(f"\n{'=' * 60}")
    print("DEFERRED DELIVERIES SUMMARY")
    print(f"{'=' * 60}")
    for shift_name in ["Shift 1", "Shift 2", "Shift 3"]:
        deferred = results[config['name']]['vrp'].get(shift_name, {}).get('deferred_nodes', [])
        if deferred:
            print(f"\n{shift_name}:")
            for node_id, target_shift in deferred:
                print(f"  Node {node_id}: Scheduled for next day in {target_shift}")

    # Classical benchmark
    print(f"\n{'=' * 60}")
    print("QUANTUM ADVANTAGE ANALYSIS")
    print(f"{'=' * 60}")
    print("\n🔄 Running classical benchmarks...")
    try:
        classical_solver = ClassicalSolver()
        classical_tsp_tour, classical_tsp_cost = classical_solver.solve_tsp_2opt(tsp_problem)
        print(f"Classical TSP ({tsp_problem.n_nodes} nodes): Cost = {classical_tsp_cost:.2f} km")
        classical_vrp_results = {}
        for shift_name in ["Shift 1", "Shift 2", "Shift 3"]:
            shift_nodes = vrp_problem.shifts.get(shift_name, [])
            if not shift_nodes:
                print(f"❌ No nodes found for {shift_name} in classical benchmark")
                continue
            shift_vrp_problem = VRPProblem(nodes=shift_nodes, vehicles=vrp_problem.vehicles, shifts=vrp_problem.shifts)
            classical_vrp_routes, classical_vrp_cost = classical_solver.solve_vrp_ortools_like(shift_vrp_problem)
            classical_vrp_results[shift_name] = {'routes': classical_vrp_routes, 'cost': classical_vrp_cost}
            print(f"Classical VRP for {shift_name} ({len(shift_nodes)} nodes, {vrp_problem.n_vehicles} vehicles): Cost = {classical_vrp_cost:.2f} km")
    except Exception as e:
        print(f"Classical benchmark failed: {e}")

    print(f"\n🎯 Key Insights:")
    print("1. Real quantum devices may have higher error rates due to noise")
    print("2. Simulators provide exact results but don't show quantum advantage")
    print("3. Problem size is limited by current quantum hardware capabilities")
    print("4. Hybrid approach combines quantum optimization with classical post-processing")
    print("5. Stronger QUBO constraints and enhanced post-processing reduce fallback reliance")
    print("6. Traffic-aware rerouting improves efficiency by optimizing routes based on fixed traffic data")

    return results

class ClassicalSolver:
    def solve_tsp_2opt(self, problem: TSPProblem) -> Tuple[List[int], float]:
        tour = [0]
        unvisited = set(range(1, problem.n_nodes))
        current = 0
        while unvisited:
            nearest = min(unvisited, key=lambda x: problem.distance_matrix[current][x])
            tour.append(nearest)
            unvisited.remove(nearest)
            current = nearest
        def tour_distance(t):
            if len(t) <= 1: return 0
            return sum(problem.distance_matrix[t[i]][t[(i+1) % len(t)]] for i in range(len(t)))
        best_tour = tour[:]
        best_distance = tour_distance(best_tour)
        improved = True
        k = 0
        while improved and k < 1000:
            improved = False
            for i in range(len(tour) - 1):
                for j in range(i + 1, len(tour)):
                    if j - i >= 1:
                        new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
                        new_distance = tour_distance(new_tour)
                        if new_distance < best_distance:
                            best_tour = new_tour[:]
                            best_distance = new_distance
                            tour = new_tour[:]
                            improved = True
                            break
                if improved:
                    break
            k += 1
        return best_tour, best_distance

    def solve_vrp_ortools_like(self, problem: VRPProblem) -> Tuple[Dict[int, List[int]], float]:
        clusters = ClassicalPreprocessor().cluster_customers_advanced(problem, max_cluster_size=4)
        routes = {}
        total_cost = 0
        for vehicle_id, cluster in clusters.items():
            if not cluster:
                continue
            cluster_node_indices = [0] + cluster
            cluster_nodes = [problem.nodes[idx] for idx in cluster_node_indices]
            cluster_distances = np.zeros((len(cluster_node_indices), len(cluster_node_indices)))
            for i in range(len(cluster_node_indices)):
                for j in range(len(cluster_node_indices)):
                    orig_i = cluster_node_indices[i]
                    orig_j = cluster_node_indices[j]
                    cluster_distances[i][j] = problem.distance_matrix[orig_i][orig_j]
            sub_problem = TSPProblem(cluster_nodes, cluster_distances)
            tour, cost = self.solve_tsp_2opt(sub_problem)
            original_tour = [cluster_node_indices[node_idx] for node_idx in tour]
            vehicle = next((v for v in problem.vehicles if v.id == vehicle_id), None)
            if vehicle:
                details = calculate_route_details(problem, vehicle, original_tour)
                if details['total_duration'] > vehicle.max_time:
                    original_tour = original_tour[:len(original_tour)//2]
                    cost = sum(problem.distance_matrix[original_tour[i]][original_tour[i+1]]
                               for i in range(len(original_tour)-1))
            routes[vehicle_id] = original_tour
            total_cost += cost
        return routes, total_cost



def group_nodes_by_shift(nodes):
    """
    Groups VRP nodes into a dictionary with shift names as keys.

    Args:
        nodes: List of Node objects with id, x, y, demand, service_time, and available_time attributes.

    Returns:
        dict: Dictionary with keys "Shift 1", "Shift 2", "Shift 3" and lists of Node objects.
    """
    shift_dict = {"Shift 1": [], "Shift 2": [], "Shift 3": []}
    for node in nodes:
        shift = node.available_time
        if shift in shift_dict:
            shift_dict[shift].append(node)
    return shift_dict

def reassign_exceeding_customers(problem: VRPProblem, routes: Dict[int, List[int]], current_shift: str) -> Tuple[Dict[int, List[int]], List[int]]:
    """
    Checks routes for time limit violations. If a violation occurs, it identifies the last
    customer in the route and interactively asks the user whether to reassign them to the next shift.

    Args:
        problem: The VRPProblem object for the current shift.
        routes: The dictionary of routes generated by a solver.
        current_shift: A string identifier for the current shift (e.g., "Shift 1").

    Returns:
        A tuple containing:
        - The modified dictionary of routes.
        - A list of customer node IDs that have been reassigned.
    """
    reassigned_customers = []
    # Create a deep copy of the routes to modify them safely
    modified_routes = {vehicle_id: list(route) for vehicle_id, route in routes.items()}

    for vehicle_id, route in routes.items():
        if not route:
            continue

        vehicle = next((v for v in problem.vehicles if v.id == vehicle_id), None)
        if not vehicle:
            continue

        details = calculate_route_details(problem, vehicle, modified_routes[vehicle_id])

        # Continuously check the route as long as it exceeds the time limit and has customers to remove
        while details['total_duration'] > vehicle.max_time and len(modified_routes[vehicle_id]) > 0:

            violating_customer_id = None
            for node_id in reversed(modified_routes[vehicle_id]):
                if node_id != 0:  # Skip depot node
                    violating_customer_id = node_id
                    break

            print(f"\n⚠️  WARNING: Vehicle {vehicle_id}'s planned route in {current_shift} exceeds its time limit.")
            print(f"    Route: {modified_routes[vehicle_id]}")
            print(f"    Total Duration: {details['total_duration']:.2f} hrs | Vehicle Max Time: {vehicle.max_time:.2f} hrs.")

            # Determine the message for the next shift
            shift_num = int(current_shift.split(' ')[1])
            if shift_num < 3:
                next_shift_msg = f"the next shift (Shift {shift_num + 1})"
            else:
                next_shift_msg = "the first shift on the next day"

            # --- INTERACTIVE USER PROMPT ---
            choice = ''
            while choice.lower().strip() not in ['yes', 'y', 'no', 'n']:
                choice = input(f"    Do you want to postpone customer {violating_customer_id} to {next_shift_msg}? (yes/no): ")
                if choice.lower().strip() not in ['yes', 'y', 'no', 'n']:
                    print("    Invalid input. Please enter 'yes' or 'no'.")

            if choice.lower().strip() in ['yes', 'y']:
                # User chose to postpone the customer
                print(f"    ✅ Customer {violating_customer_id} will be moved to the next shift.")
                modified_routes[vehicle_id].remove(violating_customer_id)
                reassigned_customers.append(violating_customer_id)

                # Recalculate route details for the while-loop's next check
                details = calculate_route_details(problem, vehicle, modified_routes[vehicle_id])
            else:
                # User chose to deliver anyway, so we accept the overage for this vehicle
                print(f"    ➡️  Acknowledged. Vehicle {vehicle_id}'s shift limit will be exceeded.")
                break  # Exit the while loop for this vehicle and keep the remaining route as is

    return modified_routes, reassigned_customers

from functools import lru_cache
def get_osrm_route_distance_and_time(start_node: Node, end_node: Node) -> Tuple[Optional[float], Optional[float]]:
    start_lon, start_lat = start_node.x, start_node.y
    end_lon, end_lat = end_node.x, end_node.y
    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {"overview": "false"}
    try:
        response = requests.get(url, params=params, timeout=5)
        response.raise_for_status()
        data = response.json()
        if data['code'] == 'Ok' and data['routes']:
            distance = data['routes'][0]['distance'] / 1000.0
            duration = data['routes'][0]['duration'] / 3600.0
            return distance, duration
        else:
            logger.warning(f"OSRM could not find route from node {start_node.id} to {end_node.id}: {data.get('message', 'No routes')}")
            return None, None
    except requests.exceptions.RequestException as e:
        logger.error(f"OSRM API error for {start_node.id} -> {end_node.id}: {e}")
        return None, None
@lru_cache(maxsize=1000)
def get_traffic_flow(api_key: str, latitude: float, longitude: float) -> dict:
    base_url = "https://api.tomtom.com/traffic/services/4/flowSegmentData/relative0/10/json"
    point = f"{latitude},{longitude}"
    params = {
        "point": point,
        "unit": "KMPH",
        "openLr": "false",
        "key": api_key
    }
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(base_url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:
                sleep_time = 2 ** attempt
                logger.warning(f"TomTom rate limit hit, retrying after {sleep_time}s")
                time.sleep(sleep_time)
                continue
            logger.error(f"TomTom API error at ({latitude}, {longitude}): {e}")
            return {"error": str(e)}
        except requests.exceptions.RequestException as e:
            logger.error(f"TomTom API error at ({latitude}, {longitude}): {e}")
            if attempt == max_retries - 1:
                return {"error": str(e)}
            time.sleep(1)
    return {"error": "Max retries exceeded"}
def get_alternative_route(problem: 'VRPProblem', start_node: Node, end_node: Node, avoid_points: List[Tuple[float, float]]) -> Tuple[Optional[float], Optional[float]]:
    start_lon, start_lat = start_node.x, start_node.y
    end_lon, end_lat = end_node.x, end_node.y
    if (start_lon, start_lat) == (end_lat, end_lon):
        logger.warning(f"Start and end nodes are the same ({start_node.id} -> {end_node.id}), no alternative route needed")
        return None, None

    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {"overview": "false", "alternatives": "true"}  # Request alternative routes

    max_retries = 3
    for attempt in range(max_retries):
        try:
            logger.debug(f"Attempting OSRM route from {start_node.id} to {end_node.id} (attempt {attempt + 1})")
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            if data['code'] == 'Ok' and data['routes']:
                # Select the shortest-duration alternative route
                best_route = min(data['routes'], key=lambda r: r['duration'])
                distance = best_route['distance'] / 1000.0
                duration = best_route['duration'] / 3600.0
                logger.info(f"OSRM route found: Distance = {distance:.2f} km, Duration = {duration:.2f} hours")
                return distance, duration
            else:
                logger.warning(f"OSRM response: {data.get('message', 'No routes found')}")
                return None, None
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:
                sleep_time = 2 ** attempt
                logger.warning(f"OSRM rate limit hit, retrying after {sleep_time}s")
                time.sleep(sleep_time)
                continue
            logger.error(f"OSRM error for {start_node.id} -> {end_node.id}: {e}, Response: {response.text}")
            return None, None
        except requests.exceptions.RequestException as e:
            logger.error(f"OSRM attempt {attempt + 1} failed for {start_node.id} -> {end_node.id}: {e}")
            if attempt == max_retries - 1:
                logger.info("All OSRM retries failed, returning None")
                return None, None
    return None, None

@lru_cache(maxsize=1000)
def _get_osrm_distance_cached(start_coords: Tuple[float, float], end_coords: Tuple[float, float]) -> Optional[float]:
    start_lon, start_lat = start_coords
    end_lon, end_lat = end_coords
    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {"overview": "false"}
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            if data['code'] == 'Ok':
                return data['routes'][0]['distance'] / 1000.0
            logger.warning(f"OSRM could not find route from {start_coords} to {end_coords}")
            return None
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:
                sleep_time = 2 ** attempt
                logger.warning(f"Rate limit hit, retrying after {sleep_time}s")
                time.sleep(sleep_time)
                continue
            logger.error(f"OSRM API error: {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"OSRM API error: {e}")
            if attempt == max_retries - 1:
                return None
            time.sleep(1)
    return None

def _get_osrm_distance(self, start_node: Node, end_node: Node) -> Optional[float]:
    return _get_osrm_distance_cached((start_node.x, start_node.y), (end_node.x, end_node.y))

# Fixed traffic analysis functions that properly handle intermediate nodes

def calculate_traffic_adjusted_time_fixed(problem: 'VRPProblem', vehicle: Vehicle, route: List[int], api_key: str) -> Tuple[float, List[dict]]:
    """
    Calculate traffic-adjusted travel time considering ALL nodes in the route sequence.
    This fixes the issue where only start/end nodes were considered.
    """
    total_travel_time = 0.0
    segment_details = []

    if len(route) <= 1:
        return 0.0, segment_details

    # Ensure depot is at start and end if not already there
    full_route = route[:]
    if full_route[0] != 0:
        full_route.insert(0, 0)
    if full_route[-1] != 0:
        full_route.append(0)

    # Analyze traffic for EACH consecutive pair of nodes in the route
    for i in range(len(full_route) - 1):
        start_node_id = full_route[i]
        end_node_id = full_route[i + 1]

        start_node = problem.nodes[start_node_id]
        end_node = problem.nodes[end_node_id]

        # Get base distance and duration for this specific segment
        distance, base_duration = get_osrm_route_distance_and_time(start_node, end_node)

        if distance is None or base_duration is None:
            logger.warning(f"Using distance matrix fallback for segment {start_node_id}->{end_node_id}")
            distance = problem.distance_matrix[start_node_id][end_node_id]
            base_duration = distance * (0.1 / vehicle.speed)

        # Get traffic data for the START of this segment
        traffic_data = get_traffic_flow(api_key, start_node.y, start_node.x)
        traffic_speed = None
        adjusted_duration = base_duration

        if 'error' not in traffic_data and 'flowSegmentData' in traffic_data:
            traffic_speed = traffic_data['flowSegmentData'].get('currentSpeed', None)
            free_flow_speed = traffic_data['flowSegmentData'].get('freeFlowSpeed', vehicle.speed * 50)

            if traffic_speed and free_flow_speed and free_flow_speed > 0:
                speed_ratio = traffic_speed / free_flow_speed
                # Apply traffic adjustment - slower traffic means longer duration
                adjusted_duration = base_duration / max(speed_ratio, 0.1)  # Prevent division by very small numbers
            else:
                adjusted_duration = base_duration
        else:
            logger.warning(f"No traffic data available for node {start_node_id} to {end_node_id}")
            adjusted_duration = base_duration

        total_travel_time += adjusted_duration

        segment_details.append({
            'start_node': start_node_id,
            'end_node': end_node_id,
            'distance': distance,
            'base_duration': base_duration,
            'traffic_adjusted_duration': adjusted_duration,
            'traffic_speed': traffic_speed,
            'segment_index': i
        })

        logger.debug(f"Segment {start_node_id}→{end_node_id}: "
                    f"Distance={distance:.2f}km, Base={base_duration:.2f}h, "
                    f"Traffic={adjusted_duration:.2f}h, Speed={traffic_speed}km/h")

    return total_travel_time, segment_details


def suggest_alternative_route_fixed(problem: 'VRPProblem', vehicle: Vehicle, route: List[int],
                                   api_key: str, current_node_idx: int) -> dict:
    """
    Fixed version that properly analyzes traffic for all intermediate nodes in the route.
    """
    if current_node_idx < 0 or current_node_idx >= len(route):
        logger.error(f"Invalid current node index {current_node_idx} for route length {len(route)}")
        return {'route': route, 'total_time': float('inf'), 'status': 'invalid_index'}

    # Get remaining route from current position
    remaining_route = route[current_node_idx:]

    # Remove redundant depot nodes at the end
    while len(remaining_route) > 1 and remaining_route[-1] == 0 and remaining_route[-2] == 0:
        remaining_route.pop()

    if len(remaining_route) <= 1:
        return {'route': route, 'total_time': 0, 'status': 'no_remaining_route'}

    # Calculate traffic-adjusted time for the ENTIRE remaining route
    total_original_time, original_segments = calculate_traffic_adjusted_time_fixed(
        problem, vehicle, remaining_route, api_key)

    logger.info(f"Vehicle {vehicle.id} remaining route analysis:")
    logger.info(f"  Route: {remaining_route}")
    logger.info(f"  Total original time: {total_original_time:.2f} hours")
    logger.info(f"  Number of segments analyzed: {len(original_segments)}")

    # Identify congested segments (traffic speed significantly below free flow)
    congested_segments = []
    alternative_needed = False

    for segment in original_segments:
        if segment['traffic_speed']:
            expected_speed = vehicle.speed * 50  # Convert vehicle speed to km/h
            congestion_threshold = 0.6  # Consider congested if speed < 60% of expected

            if segment['traffic_speed'] < (expected_speed * congestion_threshold):
                congested_segments.append(segment)
                alternative_needed = True
                logger.info(f"  Congested segment detected: {segment['start_node']}→{segment['end_node']} "
                          f"(Speed: {segment['traffic_speed']}km/h vs expected: {expected_speed}km/h)")

    if not alternative_needed:
        logger.info("  No significant congestion detected, keeping original route")
        return {
            'route': route,
            'total_time': total_original_time,
            'status': 'original',
            'segments': original_segments,
            'original_time': total_original_time,
            'congested_segments': []
        }

    # Try to find alternative routes for congested segments
    improved_route = remaining_route[:]
    improved_time = total_original_time
    improved_segments = original_segments[:]
    alternatives_found = []

    # For each congested segment, try to find an alternative
    for cong_seg in congested_segments:
        start_node = problem.nodes[cong_seg['start_node']]
        end_node = problem.nodes[cong_seg['end_node']]

        # Get alternative route avoiding congested areas
        slow_points = [(start_node.y, start_node.x)]  # Points to potentially avoid
        alt_distance, alt_duration = get_alternative_route(problem, start_node, end_node, slow_points)

        if alt_duration and alt_duration < cong_seg['traffic_adjusted_duration'] * 0.5:  # 10% improvement threshold
            alternatives_found.append({
                'segment': cong_seg,
                'alternative_distance': alt_distance,
                'alternative_duration': alt_duration,
                'time_saved': cong_seg['traffic_adjusted_duration'] - alt_duration
            })

            # Update the improved time by replacing this segment's time
            improved_time = improved_time - cong_seg['traffic_adjusted_duration'] + alt_duration

            logger.info(f"  Alternative found for {cong_seg['start_node']}→{cong_seg['end_node']}: "
                       f"Time reduced from {cong_seg['traffic_adjusted_duration']:.2f}h to {alt_duration:.2f}h")

    if alternatives_found:
        total_time_saved = sum(alt['time_saved'] for alt in alternatives_found)
        logger.info(f"  Total time saved with alternatives: {total_time_saved:.2f} hours")

        return {
            'route': route[:current_node_idx] + improved_route,
            'total_time': improved_time,
            'status': 'alternative',
            'segments': improved_segments,
            'original_time': total_original_time,
            'alternatives_found': alternatives_found,
            'congested_segments': congested_segments
        }
    else:
        logger.info("  No beneficial alternatives found")
        return {
            'route': route,
            'total_time': total_original_time,
            'status': 'original_with_congestion',
            'segments': original_segments,
            'original_time': total_original_time,
            'congested_segments': congested_segments
        }


def traffic_aware_rerouting_fixed(problem: 'VRPProblem', routes_by_vehicle: Dict[int, List[int]],
                                 api_key: str, current_positions: Dict[int, int]) -> Dict[int, dict]:
    """
    Fixed traffic-aware rerouting that properly analyzes all intermediate nodes.
    """
    if not isinstance(routes_by_vehicle, dict):
        logger.error(f"Expected dictionary for routes_by_vehicle, got {type(routes_by_vehicle)}: {routes_by_vehicle}")
        return {}

    recommendations = {}

    print(f"\n{'=' * 80}")
    print(f"ENHANCED TRAFFIC-AWARE REROUTING ANALYSIS")
    print(f"{'=' * 80}")
    print(f"Analyzing traffic conditions for all intermediate nodes in vehicle routes...")

    for vehicle_id, route in routes_by_vehicle.items():
        if not route:
            logger.info(f"Vehicle {vehicle_id} has no route")
            continue

        vehicle = next((v for v in problem.vehicles if v.id == vehicle_id), None)
        if not vehicle:
            logger.warning(f"Vehicle {vehicle_id} not found")
            continue

        current_node_idx = current_positions.get(vehicle_id, 0)
        current_node = route[current_node_idx] if current_node_idx < len(route) else None

        print(f"\n{'-' * 60}")
        print(f"VEHICLE {vehicle_id} ({vehicle.type.upper()}) ANALYSIS")
        print(f"{'-' * 60}")
        print(f"Current position: Node {current_node} (index {current_node_idx})")
        print(f"Full route: {route}")

        recommendation = suggest_alternative_route_fixed(problem, vehicle, route, api_key, current_node_idx)
        recommendations[vehicle_id] = recommendation

        # Print detailed analysis
        print(f"Status: {recommendation['status'].replace('_', ' ').title()}")
        print(f"Recommended route: {recommendation['route']}")
        print(f"Estimated total time: {recommendation['total_time']:.2f} hours")

        if recommendation['status'] == 'alternative':
            time_saved = recommendation['original_time'] - recommendation['total_time']
            print(f"Time saved: {time_saved:.2f} hours ({time_saved/recommendation['original_time']*100:.1f}% improvement)")

            if 'alternatives_found' in recommendation:
                print(f"Segments with alternatives found: {len(recommendation['alternatives_found'])}")
                for alt in recommendation['alternatives_found']:
                    seg = alt['segment']
                    print(f"  • {seg['start_node']}→{seg['end_node']}: {alt['time_saved']:.2f}h saved")

        if 'congested_segments' in recommendation and recommendation['congested_segments']:
            print(f"Congested segments detected: {len(recommendation['congested_segments'])}")
            for seg in recommendation['congested_segments']:
                print(f"  • {seg['start_node']}→{seg['end_node']}: {seg['traffic_speed']:.0f} km/h")

        # Show detailed segment analysis
        if 'segments' in recommendation:
            print(f"\nDetailed segment analysis:")
            print(f"{'Segment':<12} | {'Distance':<8} | {'Base Time':<10} | {'Traffic Time':<12} | {'Speed':<10}")
            print(f"{'-' * 65}")
            for seg in recommendation['segments']:
                speed_str = f"{seg['traffic_speed']:.0f} km/h" if seg['traffic_speed'] else "N/A"
                print(f"{seg['start_node']}→{seg['end_node']:<8} | "
                      f"{seg['distance']:<8.2f} | {seg['base_duration']:<10.2f} | "
                      f"{seg['traffic_adjusted_duration']:<12.2f} | {speed_str:<10}")

    return recommendations

def download_vrp_visualizations(problem, routes_by_vehicle, shift_name, vehicle_color_map=None, traffic_recommendations=None):
    """
    Generate VRP visualizations with shift-specific filenames.
    """
    # Default vehicle color mapping if none provided
    if vehicle_color_map is None:
        vehicle_color_map = {
            0: {'color': 'red', 'label': 'Vehicle 0'},
            1: {'color': 'blue', 'label': 'Vehicle 1'},
            2: {'color': 'green', 'label': 'Vehicle 2'},
            3: {'color': 'orange', 'label': 'Vehicle 3'},
            4: {'color': 'purple', 'label': 'Vehicle 4'}
        }

    print("\n" + "="*80)
    print(f"GENERATING SOLUTION VISUALIZATIONS FOR {shift_name}")
    print("="*80)

    # Generate traffic-aware solution if recommendations available
    if traffic_recommendations:
        print("Generating map for traffic-optimized routes...")
        optimized_routes = {
            vid: rec['route'] for vid, rec in traffic_recommendations.items()
            if isinstance(rec, dict) and 'route' in rec
        }
        if optimized_routes:
            optimized_title = f"VRP_{shift_name}_traffic_optimized"
            visualize_solution_with_folium(
                problem,
                optimized_routes,
                optimized_title,
                vehicle_color_map,
                traffic_recommendations=traffic_recommendations
            )
    print("="*80)
    return True

# FIXED FUNCTION 2: Improved get_route_geometry_from_osrm with better alternative handling
def get_route_geometry_from_osrm_fixed(start_node, end_node, use_alternative=False):
    """
    FIX: Better alternative route handling and error recovery
    """
    start_lon, start_lat = start_node.x, start_node.y
    end_lon, end_lat = end_node.x, end_node.y

    # Skip if same node
    if abs(start_lon - end_lon) < 1e-6 and abs(start_lat - end_lat) < 1e-6:
        return None

    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {"overview": "full", "geometries": "geojson"}

    if use_alternative:
        params["alternatives"] = "true"
        params["continue_straight"] = "false"  # Allow more route variation

    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()

            if data['code'] != 'Ok' or not data.get('routes'):
                logger.warning(f"OSRM no route: {start_node.id} -> {end_node.id}")
                return None

            routes = data['routes']

            # Select route based on preference
            if use_alternative and len(routes) > 1:
                # Find most different alternative (different duration/distance ratio)
                primary = routes[0]
                best_alt = None
                max_difference = 0

                for alt_route in routes[1:]:
                    duration_diff = abs(alt_route['duration'] - primary['duration']) / primary['duration']
                    if duration_diff > max_difference:
                        max_difference = duration_diff
                        best_alt = alt_route

                if best_alt and max_difference > 0.1:  # At least 10% different
                    logger.info(f"Using alternative route for {start_node.id}->{end_node.id} "
                              f"({max_difference*100:.1f}% duration difference)")
                    route_geometry = best_alt['geometry']['coordinates']
                else:
                    route_geometry = primary['geometry']['coordinates']
            else:
                route_geometry = routes[0]['geometry']['coordinates']

            return [(lat, lon) for lon, lat in route_geometry]

        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Rate limited
                wait_time = (2 ** attempt) * (1 + random.random())  # Jittered backoff
                logger.warning(f"Rate limited, waiting {wait_time:.1f}s")
                time.sleep(wait_time)
                continue
            logger.error(f"OSRM HTTP error {response.status_code}: {e}")
            return None
        except Exception as e:
            logger.error(f"OSRM error attempt {attempt+1}: {e}")
            if attempt == max_retries - 1:
                return None
            time.sleep(1)

    return None

# FIXED FUNCTION 3: Enhanced visualize_solution_with_folium with better error handling
def visualize_solution_with_folium_fixed(problem, routes_by_vehicle, title,
                                        vehicle_info_map, traffic_recommendations=None):
    """
    FIX: Better error handling and alternative route visualization
    """
    depot_node = problem.nodes[0]
    map_center = [depot_node.y, depot_node.x]

    # Create map with better tiles for route visibility
    m = folium.Map(
        location=map_center,
        zoom_start=12,
        tiles="CartoDB Positron"
    )

    # Add depot marker
    folium.Marker(
        location=[depot_node.y, depot_node.x],
        popup="<strong>Depot (Node 0)</strong>",
        tooltip="Depot",
        icon=folium.Icon(color='black', icon='home', prefix='fa')
    ).add_to(m)

    # Add customer markers
    for node in problem.nodes[1:]:
        folium.Marker(
            location=[node.y, node.x],
            popup=f"<strong>Customer {node.id}</strong><br>Demand: {node.demand}",
            tooltip=f"Customer {node.id}",
            icon=folium.Icon(color='gray', icon='user', prefix='fa')
        ).add_to(m)

    # Draw routes with improved logic
    for vehicle_id, route in routes_by_vehicle.items():
        if not route:
            continue

        vehicle_details = vehicle_info_map.get(vehicle_id, {
            'color': 'blue',
            'label': f'Vehicle {vehicle_id}'
        })
        route_color = vehicle_details['color']
        route_label = vehicle_details['label']

        # Ensure route starts and ends at depot
        viz_route = route[:]
        if viz_route[0] != 0:
            viz_route.insert(0, 0)
        if viz_route[-1] != 0:
            viz_route.append(0)

        # Check for traffic recommendations for this vehicle
        has_alternatives = False
        if traffic_recommendations and vehicle_id in traffic_recommendations:
            rec = traffic_recommendations[vehicle_id]
            has_alternatives = (rec.get('status') == 'alternative' and
                              'alternatives_found' in rec and rec['alternatives_found'])

        # Draw route segments
        for j in range(len(viz_route) - 1):
            start_node_id = viz_route[j]
            end_node_id = viz_route[j + 1]

            # Skip if same node
            if start_node_id == end_node_id:
                continue

            # Determine if this segment should use alternative path
            use_alternative_path = False
            segment_label_suffix = ""

            if has_alternatives:
                rec = traffic_recommendations[vehicle_id]
                for alt in rec.get('alternatives_found', []):
                    seg = alt.get('segment', {})
                    if (seg.get('start_node') == start_node_id and
                        seg.get('end_node') == end_node_id):
                        use_alternative_path = True
                        segment_label_suffix = " (Optimized Route)"
                        break

            start_node = problem.nodes[start_node_id]
            end_node = problem.nodes[end_node_id]

            # Get route geometry
            path_geometry = get_route_geometry_from_osrm_fixed(
                start_node, end_node, use_alternative=use_alternative_path
            )

            if path_geometry:
                # Choose line style based on route type
                line_weight = 5 if use_alternative_path else 3
                line_opacity = 0.9 if use_alternative_path else 0.7

                folium.PolyLine(
                    locations=path_geometry,
                    color=route_color,
                    weight=line_weight,
                    opacity=line_opacity,
                    tooltip=f"{route_label}: {start_node_id}→{end_node_id}{segment_label_suffix}",
                    popup=f"Distance: {problem.distance_matrix[start_node_id][end_node_id]:.2f}km"
                ).add_to(m)
            else:
                # Fallback: draw straight line if OSRM fails
                logger.warning(f"Drawing straight line for {start_node_id}->{end_node_id}")
                folium.PolyLine(
                    locations=[[start_node.y, start_node.x], [end_node.y, end_node.x]],
                    color=route_color,
                    weight=2,
                    opacity=0.5,
                    dash_array="5,5",  # Dashed line to indicate approximation
                    tooltip=f"{route_label}: {start_node_id}→{end_node_id} (Direct)"
                ).add_to(m)

    # Add legend
    legend_html = f"""
    <div style="position: fixed;
                top: 10px; right: 10px; width: 200px; height: auto;
                background-color: white; border:2px solid grey; z-index:9999;
                font-size:14px; padding: 10px">
    <p><b>{title}</b></p>
    """

    for vehicle_id, details in vehicle_info_map.items():
        if vehicle_id in routes_by_vehicle and routes_by_vehicle[vehicle_id]:
            legend_html += f'<p><i class="fa fa-minus" style="color:{details["color"]}"></i> {details["label"]}</p>'

    legend_html += "</div>"
    m.get_root().html.add_child(folium.Element(legend_html))

    # Save map
    filename = f"{title.replace(' ', '_').lower()}.html"
    try:
        m.save(filename)
        print(f"✅ Visualization saved to '{filename}'")
        return filename
    except Exception as e:
        logger.error(f"Failed to save map '{filename}': {e}")
        return None

# FIXED FUNCTION 4: Enhanced suggest_alternative_route with better thresholds
def suggest_alternative_route_enhanced(problem, vehicle, route, api_key, current_node_idx):
    """
    FIX: Better alternative detection with improved thresholds and logic
    """
    if current_node_idx < 0 or current_node_idx >= len(route):
        return {'route': route, 'total_time': float('inf'), 'status': 'invalid_index'}

    remaining_route = route[current_node_idx:]

    # Remove redundant depot nodes
    while len(remaining_route) > 1 and remaining_route[-1] == 0 and remaining_route[-2] == 0:
        remaining_route.pop()

    if len(remaining_route) <= 1:
        return {'route': route, 'total_time': 0, 'status': 'no_remaining_route'}

    # Calculate traffic-adjusted time
    total_original_time, original_segments = calculate_traffic_adjusted_time_fixed(
        problem, vehicle, remaining_route, api_key)

    logger.info(f"Vehicle {vehicle.id} route analysis: {remaining_route}")
    logger.info(f"Original time: {total_original_time:.2f}h, Segments: {len(original_segments)}")

    # Enhanced congestion detection with multiple criteria
    congested_segments = []
    alternative_needed = False

    for segment in original_segments:
        is_congested = False
        congestion_reasons = []

        if segment['traffic_speed']:
            expected_speed = vehicle.speed * 50  # Convert to km/h

            # Multiple congestion criteria
            if segment['traffic_speed'] < expected_speed * 0.7:  # < 70% of expected
                is_congested = True
                congestion_reasons.append("slow_speed")

            if segment['traffic_adjusted_duration'] > segment['base_duration'] * 1.3:  # 30% longer
                is_congested = True
                congestion_reasons.append("high_delay")

            if segment['traffic_speed'] < 20:  # Absolute slow speed
                is_congested = True
                congestion_reasons.append("absolute_slow")

        if is_congested:
            segment['congestion_reasons'] = congestion_reasons
            congested_segments.append(segment)
            alternative_needed = True
            logger.info(f"Congested: {segment['start_node']}→{segment['end_node']} "
                       f"({segment['traffic_speed']:.0f} km/h, reasons: {congestion_reasons})")

    if not alternative_needed:
        logger.info("No significant congestion detected")
        return {
            'route': route,
            'total_time': total_original_time,
            'status': 'original',
            'segments': original_segments,
            'original_time': total_original_time,
            'congested_segments': []
        }

    # Try to find alternatives with more aggressive search
    improved_route = remaining_route[:]
    improved_time = total_original_time
    alternatives_found = []

    # Group consecutive congested segments for better alternative routing
    congested_groups = []
    current_group = []

    for i, segment in enumerate(original_segments):
        if segment in congested_segments:
            current_group.append(segment)
        else:
            if current_group:
                congested_groups.append(current_group)
                current_group = []
    if current_group:
        congested_groups.append(current_group)

    # Find alternatives for each congested group
    total_time_saved = 0

    for group in congested_groups:
        if len(group) == 1:
            # Single segment alternative
            seg = group[0]
            start_node = problem.nodes[seg['start_node']]
            end_node = problem.nodes[seg['end_node']]

            # More aggressive alternative search
            slow_points = [(start_node.y, start_node.x)]
            alt_distance, alt_duration = get_alternative_route(problem, start_node, end_node, slow_points)

            # Lower threshold for accepting alternatives (5% improvement)
            if alt_duration and alt_duration < seg['traffic_adjusted_duration'] * 0.95:
                time_saved = seg['traffic_adjusted_duration'] - alt_duration
                alternatives_found.append({
                    'segment': seg,
                    'alternative_distance': alt_distance,
                    'alternative_duration': alt_duration,
                    'time_saved': time_saved
                })
                total_time_saved += time_saved
                logger.info(f"Alternative found: {seg['start_node']}→{seg['end_node']} "
                           f"saves {time_saved:.2f}h")
        else:
            # Multi-segment group - find route from start to end of group
            group_start = group[0]['start_node']
            group_end = group[-1]['end_node']
            group_original_time = sum(s['traffic_adjusted_duration'] for s in group)

            start_node = problem.nodes[group_start]
            end_node = problem.nodes[group_end]

            alt_distance, alt_duration = get_alternative_route(problem, start_node, end_node, [])

            if alt_duration and alt_duration < group_original_time * 0.9:  # 10% improvement for groups
                time_saved = group_original_time - alt_duration
                alternatives_found.append({
                    'segment_group': group,
                    'group_start': group_start,
                    'group_end': group_end,
                    'alternative_distance': alt_distance,
                    'alternative_duration': alt_duration,
                    'time_saved': time_saved
                })
                total_time_saved += time_saved
                logger.info(f"Group alternative: {group_start}→{group_end} "
                           f"saves {time_saved:.2f}h")

    improved_time = total_original_time - total_time_saved

    if alternatives_found:
        logger.info(f"Total time saved: {total_time_saved:.2f}h "
                   f"({total_time_saved/total_original_time*100:.1f}%)")

        return {
            'route': route[:current_node_idx] + improved_route,
            'total_time': improved_time,
            'status': 'alternative',
            'segments': original_segments,
            'original_time': total_original_time,
            'alternatives_found': alternatives_found,
            'congested_segments': congested_segments,
            'time_saved': total_time_saved
        }
    else:
        logger.info("No beneficial alternatives found despite congestion")
        return {
            'route': route,
            'total_time': total_original_time,
            'status': 'original_with_congestion',
            'segments': original_segments,
            'original_time': total_original_time,
            'congested_segments': congested_segments
        }

import requests
import folium
import logging

logger = logging.getLogger(__name__)

def get_route_with_instructions(start_node, end_node, use_alternative=False):
    """
    Get route geometry along with turn-by-turn instructions from OSRM
    """
    start_lon, start_lat = start_node.x, start_node.y
    end_lon, end_lat = end_node.x, end_node.y

    # Skip if same node
    if abs(start_lon - end_lon) < 1e-6 and abs(start_lat - end_lat) < 1e-6:
        return None, []

    loc_param = f"{start_lon},{start_lat};{end_lon},{end_lat}"
    url = f"http://router.project-osrm.org/route/v1/driving/{loc_param}"
    params = {
        "overview": "full",
        "geometries": "geojson",
        "steps": "true",  # Include turn-by-turn instructions
        "annotations": "true"
    }

    if use_alternative:
        params["alternatives"] = "true"
        params["continue_straight"] = "false"

    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()

            if data['code'] != 'Ok' or not data.get('routes'):
                logger.warning(f"OSRM no route: {start_node.id} -> {end_node.id}")
                return None, []

            routes = data['routes']
            selected_route = routes[0]

            # Select alternative route if requested and available
            if use_alternative and len(routes) > 1:
                # Find most different alternative
                primary = routes[0]
                best_alt = None
                max_difference = 0

                for alt_route in routes[1:]:
                    duration_diff = abs(alt_route['duration'] - primary['duration']) / primary['duration']
                    if duration_diff > max_difference:
                        max_difference = duration_diff
                        best_alt = alt_route

                if best_alt and max_difference > 0.1:
                    selected_route = best_alt
                    logger.info(f"Using alternative route for {start_node.id}->{end_node.id}")

            # Extract geometry
            route_geometry = [(lat, lon) for lon, lat in selected_route['geometry']['coordinates']]

            # Extract turn-by-turn instructions
            instructions = []
            if 'legs' in selected_route:
                for leg in selected_route['legs']:
                    if 'steps' in leg:
                        for step in leg['steps']:
                            instruction = {
                                'maneuver': step.get('maneuver', {}).get('type', 'continue'),
                                'instruction': step.get('name', 'Continue'),
                                'distance': step.get('distance', 0),
                                'duration': step.get('duration', 0),
                                'modifier': step.get('maneuver', {}).get('modifier', ''),
                                'location': step.get('maneuver', {}).get('location', [])
                            }
                            instructions.append(instruction)

            return route_geometry, instructions

        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:
                wait_time = (2 ** attempt) * (1 + random.random())
                logger.warning(f"Rate limited, waiting {wait_time:.1f}s")
                time.sleep(wait_time)
                continue
            logger.error(f"OSRM HTTP error {response.status_code}: {e}")
            return None, []
        except Exception as e:
            logger.error(f"OSRM error attempt {attempt+1}: {e}")
            if attempt == max_retries - 1:
                return None, []
            time.sleep(1)

    return None, []

def format_navigation_instruction(instruction):
    """
    Format navigation instruction into human-readable text
    """
    maneuver = instruction.get('maneuver', 'continue')
    modifier = instruction.get('modifier', '')
    street_name = instruction.get('instruction', 'Continue')
    distance = instruction.get('distance', 0)

    # Create human-readable instruction
    instruction_text = ""

    if maneuver == 'turn':
        if modifier == 'left':
            instruction_text = f"Turn left onto {street_name}"
        elif modifier == 'right':
            instruction_text = f"Turn right onto {street_name}"
        elif modifier == 'sharp left':
            instruction_text = f"Take a sharp left onto {street_name}"
        elif modifier == 'sharp right':
            instruction_text = f"Take a sharp right onto {street_name}"
        elif modifier == 'slight left':
            instruction_text = f"Bear left onto {street_name}"
        elif modifier == 'slight right':
            instruction_text = f"Bear right onto {street_name}"
        else:
            instruction_text = f"Turn onto {street_name}"
    elif maneuver == 'merge':
        instruction_text = f"Merge onto {street_name}"
    elif maneuver == 'on ramp' or maneuver == 'ramp':
        instruction_text = f"Take the ramp onto {street_name}"
    elif maneuver == 'off ramp':
        instruction_text = f"Take the exit onto {street_name}"
    elif maneuver == 'fork':
        if modifier == 'left':
            instruction_text = f"Keep left at the fork onto {street_name}"
        elif modifier == 'right':
            instruction_text = f"Keep right at the fork onto {street_name}"
        else:
            instruction_text = f"Continue at the fork onto {street_name}"
    elif maneuver == 'roundabout':
        instruction_text = f"Enter roundabout and take exit onto {street_name}"
    elif maneuver == 'continue' or maneuver == 'straight':
        instruction_text = f"Continue straight on {street_name}"
    else:
        instruction_text = f"Continue on {street_name}"

    # Add distance information
    if distance > 1000:
        instruction_text += f" for {distance/1000:.1f} km"
    elif distance > 0:
        instruction_text += f" for {distance:.0f} m"

    return instruction_text

def create_instruction_popup(instructions, segment_info=None):
    """
    Create HTML popup content with navigation instructions
    """
    html_content = "<div style='max-width: 300px; max-height: 200px; overflow-y: auto;'>"

    if segment_info:
        html_content += f"<h4 style='margin: 0 0 10px 0; color: #2E8B57;'>🚗 Optimized Route</h4>"
        html_content += f"<p style='margin: 0 0 5px 0;'><strong>Distance:</strong> {segment_info.get('distance', 0):.2f} km</p>"
        html_content += f"<p style='margin: 0 0 10px 0;'><strong>Est. Time:</strong> {segment_info.get('duration', 0)*60:.0f} min</p>"

    if instructions:
        html_content += "<h5 style='margin: 0 0 5px 0;'>Turn-by-turn directions:</h5>"
        html_content += "<ol style='margin: 0; padding-left: 20px; font-size: 12px;'>"

        for i, instruction in enumerate(instructions[:8]):  # Limit to first 8 instructions
            formatted_instruction = format_navigation_instruction(instruction)
            html_content += f"<li style='margin-bottom: 3px;'>{formatted_instruction}</li>"

        if len(instructions) > 8:
            html_content += f"<li style='color: #666; font-style: italic;'>... and {len(instructions) - 8} more turns</li>"

        html_content += "</ol>"
    else:
        html_content += "<p style='color: #666; font-style: italic;'>Navigation details not available</p>"

    html_content += "</div>"
    return html_content

def visualize_solution_with_navigation_instructions(problem, routes_by_vehicle, title,
                                                  vehicle_info_map, traffic_recommendations=None):
    """
    Enhanced visualization that shows navigation instructions for optimized routes
    """
    depot_node = problem.nodes[0]
    map_center = [depot_node.y, depot_node.x]

    # Create map with better tiles for route visibility
    m = folium.Map(
        location=map_center,
        zoom_start=12,
        tiles="CartoDB Positron"
    )

    # Add depot marker
    folium.Marker(
        location=[depot_node.y, depot_node.x],
        popup="<strong>Depot (Node 0)</strong>",
        tooltip="Depot",
        icon=folium.Icon(color='black', icon='home', prefix='fa')
    ).add_to(m)

    # Add customer markers
    for node in problem.nodes[1:]:
        folium.Marker(
            location=[node.y, node.x],
            popup=f"<strong>Customer {node.id}</strong><br>Demand: {node.demand}",
            tooltip=f"Customer {node.id}",
            icon=folium.Icon(color='gray', icon='user', prefix='fa')
        ).add_to(m)

    # Draw routes with enhanced navigation instructions
    for vehicle_id, route in routes_by_vehicle.items():
        if not route:
            continue

        vehicle_details = vehicle_info_map.get(vehicle_id, {
            'color': 'blue',
            'label': f'Vehicle {vehicle_id}'
        })
        route_color = vehicle_details['color']
        route_label = vehicle_details['label']

        # Ensure route starts and ends at depot
        viz_route = route[:]
        if viz_route[0] != 0:
            viz_route.insert(0, 0)
        if viz_route[-1] != 0:
            viz_route.append(0)

        # Get traffic recommendations for this vehicle
        traffic_rec = None
        optimized_segments = set()
        if traffic_recommendations and vehicle_id in traffic_recommendations:
            traffic_rec = traffic_recommendations[vehicle_id]
            if traffic_rec.get('status') == 'alternative' and 'alternatives_found' in traffic_rec:
                for alt in traffic_rec['alternatives_found']:
                    seg = alt.get('segment', {})
                    optimized_segments.add((seg.get('start_node'), seg.get('end_node')))

        # Draw route segments
        for j in range(len(viz_route) - 1):
            start_node_id = viz_route[j]
            end_node_id = viz_route[j + 1]

            # Skip if same node
            if start_node_id == end_node_id:
                continue

            start_node = problem.nodes[start_node_id]
            end_node = problem.nodes[end_node_id]

            # Check if this segment is optimized
            is_optimized_segment = (start_node_id, end_node_id) in optimized_segments

            # Get route geometry and instructions
            if is_optimized_segment:
                # Get alternative route with navigation instructions
                path_geometry, instructions = get_route_with_instructions(
                    start_node, end_node, use_alternative=True
                )
                line_weight = 6
                line_opacity = 0.9
                line_color = '#FF6B35'  # Orange-red for optimized routes

                # Get segment info for popup
                segment_info = None
                if traffic_rec and 'alternatives_found' in traffic_rec:
                    for alt in traffic_rec['alternatives_found']:
                        seg = alt.get('segment', {})
                        if (seg.get('start_node') == start_node_id and
                            seg.get('end_node') == end_node_id):
                            segment_info = {
                                'distance': alt.get('alternative_distance', 0),
                                'duration': alt.get('alternative_duration', 0),
                                'time_saved': alt.get('time_saved', 0)
                            }
                            break

                # Create enhanced popup with navigation instructions
                popup_content = create_instruction_popup(instructions, segment_info)
                tooltip_text = f"🚗 {route_label}: {start_node_id}→{end_node_id} (OPTIMIZED ROUTE - Click for directions)"

            else:
                # Regular route
                path_geometry, instructions = get_route_with_instructions(
                    start_node, end_node, use_alternative=False
                )
                line_weight = 3
                line_opacity = 0.7
                line_color = route_color
                popup_content = f"<strong>{route_label}</strong><br>Segment: {start_node_id}→{end_node_id}<br>Distance: {problem.distance_matrix[start_node_id][end_node_id]:.2f}km"
                tooltip_text = f"{route_label}: {start_node_id}→{end_node_id}"

            if path_geometry:
                folium.PolyLine(
                    locations=path_geometry,
                    color=line_color,
                    weight=line_weight,
                    opacity=line_opacity,
                    tooltip=tooltip_text,
                    popup=folium.Popup(popup_content, max_width=350)
                ).add_to(m)

                # Add arrow markers for optimized routes to show direction
                if is_optimized_segment and len(path_geometry) > 10:
                    # Add arrow at midpoint of optimized routes
                    mid_point = len(path_geometry) // 2
                    folium.Marker(
                        location=path_geometry[mid_point],
                        icon=folium.plugins.BeautifyIcon(
                            icon="arrow-right",
                            iconShape="marker",
                            textColor="white",
                            backgroundColor=line_color,
                            borderColor="white",
                            borderWidth=2
                        ),
                        tooltip="Optimized route direction"
                    ).add_to(m)

            else:
                # Fallback: draw straight line if OSRM fails
                logger.warning(f"Drawing straight line for {start_node_id}->{end_node_id}")
                folium.PolyLine(
                    locations=[[start_node.y, start_node.x], [end_node.y, end_node.x]],
                    color=line_color,
                    weight=2,
                    opacity=0.5,
                    dash_array="5,5",
                    tooltip=tooltip_text,
                    popup=popup_content
                ).add_to(m)

    # Enhanced legend with optimization info
    legend_html = f"""
    <div style="position: fixed;
                top: 10px; right: 10px; width: 250px; height: auto;
                background-color: white; border:2px solid grey; z-index:9999;
                font-size:14px; padding: 10px">
    <p><b>{title}</b></p>
    """

    # Add vehicle legend entries
    for vehicle_id, details in vehicle_info_map.items():
        if vehicle_id in routes_by_vehicle and routes_by_vehicle[vehicle_id]:
            legend_html += f'<p><i class="fa fa-minus" style="color:{details["color"]}"></i> {details["label"]}</p>'

    # Add optimization legend
    has_optimizations = False
    if traffic_recommendations:
        for vehicle_id, rec in traffic_recommendations.items():
            if rec.get('status') == 'alternative':
                has_optimizations = True
                break

    if has_optimizations:
        legend_html += '<hr style="margin: 10px 0;">'
        legend_html += '<p><strong>Route Optimization:</strong></p>'
        legend_html += '<p><i class="fa fa-minus" style="color:#FF6B35; font-weight:bold;"></i> Optimized Route (with navigation)</p>'
        legend_html += '<p style="font-size:12px; color:#666;">🔍 Hover or click optimized routes for turn-by-turn directions</p>'

    legend_html += "</div>"
    m.get_root().html.add_child(folium.Element(legend_html))

    # Save map
    filename = f"{title.replace(' ', '_').lower()}.html"
    try:
        m.save(filename)
        print(f"✅ Enhanced visualization with navigation saved to '{filename}'")
        print(f"🗺️  Optimized route segments now show turn-by-turn directions on hover/click")
        return filename
    except Exception as e:
        logger.error(f"Failed to save enhanced map '{filename}': {e}")
        return None

# Updated download function to use the enhanced visualization
def download_vrp_visualizations_with_navigation(problem, routes_by_vehicle, shift_name,
                                               vehicle_color_map=None, traffic_recommendations=None):
    """
    Generate VRP visualizations with navigation instructions for optimized routes.
    """
    # Default vehicle color mapping if none provided
    if vehicle_color_map is None:
        vehicle_color_map = {
            0: {'color': 'red', 'label': 'Vehicle 0'},
            1: {'color': 'blue', 'label': 'Vehicle 1'},
            2: {'color': 'green', 'label': 'Vehicle 2'},
            3: {'color': 'orange', 'label': 'Vehicle 3'},
            4: {'color': 'purple', 'label': 'Vehicle 4'}
        }

    print("\n" + "="*80)
    print(f"GENERATING ENHANCED SOLUTION VISUALIZATIONS FOR {shift_name}")
    print("="*80)

    # Generate traffic-aware solution with navigation instructions
    if traffic_recommendations:
        print("Generating enhanced map with navigation instructions for optimized routes...")
        optimized_routes = {
            vid: rec['route'] for vid, rec in traffic_recommendations.items()
            if isinstance(rec, dict) and 'route' in rec
        }
        if optimized_routes:
            optimized_title = f"VRP_{shift_name}_traffic_optimized_with_navigation"
            filename = visualize_solution_with_navigation_instructions(
                problem,
                optimized_routes,
                optimized_title,
                vehicle_color_map,
                traffic_recommendations=traffic_recommendations
            )
            if filename:
                print(f"🎯 Navigation-enhanced visualization created!")
                print(f"📍 Hover over orange/red route segments to see turn-by-turn directions")
                print(f"🔄 Click on optimized route segments for detailed navigation popup")

    print("="*80)
    return True

# Example usage function
def example_usage():
    """
    Example of how to use the enhanced visualization with navigation instructions
    """
    print("""
    USAGE EXAMPLE:

    # After getting your traffic recommendations from traffic_aware_rerouting_fixed()
    traffic_recommendations = traffic_aware_rerouting_fixed(
        problem, routes_by_vehicle, api_key, current_positions
    )

    # Generate enhanced visualizations with navigation instructions
    download_vrp_visualizations_with_navigation(
        problem=problem,
        routes_by_vehicle=routes_by_vehicle,
        shift_name="morning_shift",
        vehicle_color_map=vehicle_color_map,
        traffic_recommendations=traffic_recommendations
    )

    # The resulting HTML file will show:
    # - Regular routes in vehicle colors
    # - Optimized routes in orange/red with thicker lines
    # - Hover tooltips indicating optimized routes
    # - Click popups with turn-by-turn navigation instructions
    # - Direction arrows on optimized route segments
    """)
# new function for API
def solve_vrp_from_api(nodes_data: list, vehicles_data: list):
    """
    Takes raw node and vehicle data from an API, groups them by shift,
    and runs the VRP solver for each shift to produce detailed output.
    """
    try:
        # Convert raw dictionaries to your internal Node and Vehicle objects
        nodes = [Node(**n) for n in nodes_data]
        vehicles = [Vehicle(**v) for v in vehicles_data]

        # Group nodes by shift
        shifts = group_nodes_by_shift(nodes)

        all_routes_by_shift = {}
        all_costs_by_shift = {}
        all_details_by_shift = {}
        total_fleet_cost = 0

        # Process shifts in a consistent order
        shift_order = sorted(shifts.keys()) 
        
        for shift_name in shift_order:
            if not shifts[shift_name]:
                continue
            
            shift_nodes = shifts[shift_name]
            
            # Create a new problem instance for the current shift
            shift_vrp_problem = VRPProblem(nodes=shift_nodes, vehicles=vehicles)
            
            # Instantiate the solver
            solver = QuantumHybridSolver(
                quantum_backend='qiskit',
                use_aer=True,
                shots=1024,
                p_layers=3,
                optimizer='COBYLA',
                problem_obj=None
            )
            
            # Solve the VRP for the current shift
            routes, total_cost, details = solver.solve_vrp_quantum(
                shift_vrp_problem,
                num_runs=2,
                clustering_method='spectral'
            )
            
            all_routes_by_shift[shift_name] = routes
            all_costs_by_shift[shift_name] = total_cost
            all_details_by_shift[shift_name] = details
            
            total_fleet_cost += total_cost
            
        # Format the comprehensive output
        response = {
            "solution_found": True,
            "total_fleet_cost": total_fleet_cost,
            "shift_solutions": []
        }
        
        for shift_name in shift_order:
            if shift_name in all_routes_by_shift:
                routes = all_routes_by_shift[shift_name]
                cost = all_costs_by_shift[shift_name]
                details = all_details_by_shift[shift_name]
                
                response["shift_solutions"].append({
                    "shift_name": shift_name,
                    "cost": cost,
                    "routes": routes,
                    "schedule_output": "String output not implemented in this version.",
                    "summary_output": "String output not implemented in this version."
                })
        
        return response
    
    except Exception as e:
        import traceback
        return {
            "solution_found": False,
            "error": str(e),
            "traceback": traceback.format_exc()
        }
if __name__ == "__main__":
    import argparse
    import uvicorn
    import sys
    import os
    
    # Add a command-line argument to select the mode
    parser = argparse.ArgumentParser(description="Run the Quantum TSP/VRP Solver in a specified mode.")
    parser.add_argument("--mode", type=str, default="cli", choices=["cli", "api"],
                        help="The execution mode. 'cli' for command line (default data), 'api' for FastAPI.")
    args = parser.parse_args()

    if args.mode == "cli":
        # This block contains your original script's logic
        print("🚀 IBM Quantum TSP/VRP Solver with Real Road Network")
        print("=" * 50)
        if not QISKIT_AVAILABLE:
            print("❌ Qiskit not available. Please install:")
            print("pip install qiskit qiskit-ibm-runtime qiskit-aer qiskit-algorithms")
        if QISKIT_AVAILABLE and IBM_RUNTIME_AVAILABLE:
            check_quantum_connectivity()
        else:
            print("\nSkipping IBM Quantum connectivity check")
        print(f"\n🎯 Starting quantum experiments...")
        try:
            QiskitRuntimeService.delete_account()
            QiskitRuntimeService.save_account(
                channel="ibm_cloud",
                token="S24GFhGFFjQ54O839cRmwC7bvMY4SNObsh-DaU22uL6g",
                instance="Path_optimization",
                overwrite=True
            )
            service = QiskitRuntimeService()

            # Fixes for local execution
            import sys
            current_module = sys.modules[__name__]
            current_module.calculate_traffic_adjusted_time = calculate_traffic_adjusted_time_fixed
            current_module.suggest_alternative_route = suggest_alternative_route_fixed
            current_module.traffic_aware_rerouting = traffic_aware_rerouting_fixed

            results = run_ibm_quantum_experiments()
            print(f"\n🎉 Experiments completed!")
            find_vrp_qubit_requirement(13, 5)
        except KeyboardInterrupt:
            print(f"\n⏹ Experiments interrupted by user")
        except Exception as e:
            print(f"\n❌ An error occurred: {e}")
            import traceback
            traceback.print_exc()

    elif args.mode == "api":
        # This is the new block that runs your FastAPI app
        try:
            # Note: Ensure `app.py` is in the same directory and the `app` object is defined in it.
            from app import app
            print("Starting FastAPI server in API mode...")
            uvicorn.run(app)
        except ImportError:
            print("❌ Error: 'app.py' not found or could not be imported.")
            print("Please ensure 'app.py' is in the same directory.")